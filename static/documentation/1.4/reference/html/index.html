<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Gunnar Morling, Andreas Gudian, Sjaak Derksen, Filip Hrisafov and the MapStruct community">
<title>MapStruct 1.4.2.Final Reference Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>MapStruct 1.4.2.Final Reference Guide</h1>
<div class="details">
<span id="author" class="author">Gunnar Morling, Andreas Gudian, Sjaak Derksen, Filip Hrisafov and the MapStruct community</span><br>
<span id="revdate">2021-01-31</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#Preface">Preface</a></li>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#setup">2. Set up</a>
<ul class="sectlevel2">
<li><a href="#_apache_maven">2.1. Apache Maven</a></li>
<li><a href="#_gradle">2.2. Gradle</a></li>
<li><a href="#_apache_ant">2.3. Apache Ant</a></li>
<li><a href="#configuration-options">2.4. Configuration options</a></li>
<li><a href="#_using_mapstruct_on_java_9">2.5. Using MapStruct on Java 9</a></li>
</ul>
</li>
<li><a href="#defining-mapper">3. Defining a mapper</a>
<ul class="sectlevel2">
<li><a href="#basic-mappings">3.1. Basic mappings</a></li>
<li><a href="#mapping-composition">3.2. Mapping Composition (experimental)</a></li>
<li><a href="#adding-custom-methods">3.3. Adding custom methods to mappers</a></li>
<li><a href="#mappings-with-several-source-parameters">3.4. Mapping methods with several source parameters</a></li>
<li><a href="#mapping-nested-bean-properties-to-current-target">3.5. Mapping nested bean properties to current target</a></li>
<li><a href="#updating-bean-instances">3.6. Updating existing bean instances</a></li>
<li><a href="#direct-field-mappings">3.7. Mappings with direct field access</a></li>
<li><a href="#mapping-with-builders">3.8. Using builders</a></li>
<li><a href="#mapping-with-constructors">3.9. Using Constructors</a></li>
</ul>
</li>
<li><a href="#retrieving-mapper">4. Retrieving a mapper</a>
<ul class="sectlevel2">
<li><a href="#mappers-factory">4.1. The Mappers factory (no dependency injection)</a></li>
<li><a href="#using-dependency-injection">4.2. Using dependency injection</a></li>
<li><a href="#injection-strategy">4.3. Injection strategy</a></li>
</ul>
</li>
<li><a href="#datatype-conversions">5. Data type conversions</a>
<ul class="sectlevel2">
<li><a href="#implicit-type-conversions">5.1. Implicit type conversions</a></li>
<li><a href="#mapping-object-references">5.2. Mapping object references</a></li>
<li><a href="#controlling-nested-bean-mappings">5.3. Controlling nested bean mappings</a></li>
<li><a href="#invoking-custom-mapping-method">5.4. Invoking custom mapping method</a></li>
<li><a href="#invoking-other-mappers">5.5. Invoking other mappers</a></li>
<li><a href="#passing-target-type">5.6. Passing the mapping target type to custom mappers</a></li>
<li><a href="#passing-context">5.7. Passing context or state objects to custom methods</a></li>
<li><a href="#mapping-method-resolution">5.8. Mapping method resolution</a></li>
<li><a href="#selection-based-on-qualifiers">5.9. Mapping method selection based on qualifiers</a></li>
</ul>
</li>
<li><a href="#mapping-collections">6. Mapping collections</a>
<ul class="sectlevel2">
<li><a href="#mapping-maps">6.1. Mapping maps</a></li>
<li><a href="#collection-mapping-strategies">6.2. Collection mapping strategies</a></li>
<li><a href="#implementation-types-for-collection-mappings">6.3. Implementation types used for collection mappings</a></li>
</ul>
</li>
<li><a href="#mapping-streams">7. Mapping Streams</a></li>
<li><a href="#mapping-enum-types">8. Mapping Values</a>
<ul class="sectlevel2">
<li><a href="#_mapping_enum_to_enum_types">8.1. Mapping enum to enum types</a></li>
<li><a href="#_mapping_enum_to_string_or_string_to_enum">8.2. Mapping enum-to-String or String-to-enum</a></li>
<li><a href="#_custom_name_transformation">8.3. Custom name transformation</a></li>
</ul>
</li>
<li><a href="#object-factories">9. Object factories</a></li>
<li><a href="#_advanced_mapping_options">10. Advanced mapping options</a>
<ul class="sectlevel2">
<li><a href="#default-values-and-constants">10.1. Default values and constants</a></li>
<li><a href="#expressions">10.2. Expressions</a></li>
<li><a href="#default-expressions">10.3. Default Expressions</a></li>
<li><a href="#determining-result-type">10.4. Determining the result type</a></li>
<li><a href="#mapping-result-for-null-arguments">10.5. Controlling mapping result for 'null' arguments</a></li>
<li><a href="#mapping-result-for-null-properties">10.6. Controlling mapping result for 'null' properties in bean mappings (update mapping methods only).</a></li>
<li><a href="#checking-source-property-for-null-arguments">10.7. Controlling checking result for 'null' properties in bean mapping</a></li>
<li><a href="#source-presence-check">10.8. Source presence checking</a></li>
<li><a href="#exceptions">10.9. Exceptions</a></li>
</ul>
</li>
<li><a href="#_reusing_mapping_configurations">11. Reusing mapping configurations</a>
<ul class="sectlevel2">
<li><a href="#mapping-configuration-inheritance">11.1. Mapping configuration inheritance</a></li>
<li><a href="#inverse-mappings">11.2. Inverse mappings</a></li>
<li><a href="#shared-configurations">11.3. Shared configurations</a></li>
</ul>
</li>
<li><a href="#_customizing_mappings">12. Customizing mappings</a>
<ul class="sectlevel2">
<li><a href="#customizing-mappers-using-decorators">12.1. Mapping customization with decorators</a></li>
<li><a href="#customizing-mappings-with-before-and-after">12.2. Mapping customization with before-mapping and after-mapping methods</a></li>
</ul>
</li>
<li><a href="#using-spi">13. Using the MapStruct SPI</a>
<ul class="sectlevel2">
<li><a href="#_custom_accessor_naming_strategy">13.1. Custom Accessor Naming Strategy</a></li>
<li><a href="#_mapping_exclusion_provider">Mapping Exclusion Provider</a></li>
<li><a href="#custom-builder-provider">13.2. Custom Builder Provider</a></li>
<li><a href="#custom-enum-naming-strategy">13.3. Custom Enum Naming Strategy</a></li>
<li><a href="#custom-enum-transformation-strategy">13.4. Custom Enum Transformation Strategy</a></li>
</ul>
</li>
<li><a href="#third-party-api-integration">14. Third-party API integration</a>
<ul class="sectlevel2">
<li><a href="#non-shipped-annotations">14.1. Non-shipped annotations</a></li>
<li><a href="#lombok">14.2. Lombok</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="Preface"><a class="anchor" href="#Preface"></a>Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is the reference documentation of MapStruct, an annotation processor for generating type-safe, performant and dependency-free bean mapping code.
This guide covers all the functionality provided by MapStruct. In case this guide doesn&#8217;t answer all your questions just join the MapStruct <a href="https://groups.google.com/forum/?fromgroups#!forum/mapstruct-users">Google group</a> to get help.</p>
</div>
<div class="paragraph">
<p>You found a typo or other error in this guide? Please let us know by opening an issue in the <a href="https://github.com/mapstruct/mapstruct">MapStruct GitHub repository</a>,
or, better yet, help the community and send a pull request for fixing it!</p>
</div>
<div class="paragraph">
<p>This work is licensed under the <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MapStruct is a Java <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/apt/index.html">annotation processor</a> for the generation of type-safe bean mapping classes.</p>
</div>
<div class="paragraph">
<p>All you have to do is to define a mapper interface which declares any required mapping methods. During compilation, MapStruct will generate an implementation of this interface. This implementation uses plain Java method invocations for mapping between source and target objects, i.e. no reflection or similar.</p>
</div>
<div class="paragraph">
<p>Compared to writing mapping code from hand, MapStruct saves time by generating code which is tedious and error-prone to write. Following a convention over configuration approach, MapStruct uses sensible defaults but steps out of your way when it comes to configuring or implementing special behavior.</p>
</div>
<div class="paragraph">
<p>Compared to dynamic mapping frameworks, MapStruct offers the following advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fast execution by using plain method invocations instead of reflection</p>
</li>
<li>
<p>Compile-time type safety: Only objects and attributes mapping to each other can be mapped, no accidental mapping of an order entity into a customer DTO etc.</p>
</li>
<li>
<p>Clear error-reports at build time, if</p>
<div class="ulist">
<ul>
<li>
<p>mappings are incomplete (not all target properties are mapped)</p>
</li>
<li>
<p>mappings are incorrect (cannot find a proper mapping method or type conversion)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setup"><a class="anchor" href="#setup"></a>2. Set up</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MapStruct is a Java annotation processor based on <a href="http://www.jcp.org/en/jsr/detail?id=269">JSR 269</a> and as such can be used within command line builds (javac, Ant, Maven etc.) as well as from within your IDE.</p>
</div>
<div class="paragraph">
<p>It comprises the following artifacts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>org.mapstruct:mapstruct</em>: contains the required annotations such as <code>@Mapping</code></p>
</li>
<li>
<p><em>org.mapstruct:mapstruct-processor</em>: contains the annotation processor which generates mapper implementations</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_apache_maven"><a class="anchor" href="#_apache_maven"></a>2.1. Apache Maven</h3>
<div class="paragraph">
<p>For Maven based projects add the following to your POM file in order to use MapStruct:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Maven configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td>
  <td class="code"><pre>...
<span class="tag">&lt;properties&gt;</span>
    <span class="tag">&lt;org.mapstruct.version&gt;</span>1.4.2.Final<span class="tag">&lt;/org.mapstruct.version&gt;</span>
<span class="tag">&lt;/properties&gt;</span>
...
<span class="tag">&lt;dependencies&gt;</span>
    <span class="tag">&lt;dependency&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>org.mapstruct<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>mapstruct<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;version&gt;</span>${org.mapstruct.version}<span class="tag">&lt;/version&gt;</span>
    <span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;/dependencies&gt;</span>
...
<span class="tag">&lt;build&gt;</span>
    <span class="tag">&lt;plugins&gt;</span>
        <span class="tag">&lt;plugin&gt;</span>
            <span class="tag">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/groupId&gt;</span>
            <span class="tag">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="tag">&lt;/artifactId&gt;</span>
            <span class="tag">&lt;version&gt;</span>3.8.1<span class="tag">&lt;/version&gt;</span>
            <span class="tag">&lt;configuration&gt;</span>
                <span class="tag">&lt;source&gt;</span>1.8<span class="tag">&lt;/source&gt;</span>
                <span class="tag">&lt;target&gt;</span>1.8<span class="tag">&lt;/target&gt;</span>
                <span class="tag">&lt;annotationProcessorPaths&gt;</span>
                    <span class="tag">&lt;path&gt;</span>
                        <span class="tag">&lt;groupId&gt;</span>org.mapstruct<span class="tag">&lt;/groupId&gt;</span>
                        <span class="tag">&lt;artifactId&gt;</span>mapstruct-processor<span class="tag">&lt;/artifactId&gt;</span>
                        <span class="tag">&lt;version&gt;</span>${org.mapstruct.version}<span class="tag">&lt;/version&gt;</span>
                    <span class="tag">&lt;/path&gt;</span>
                <span class="tag">&lt;/annotationProcessorPaths&gt;</span>
            <span class="tag">&lt;/configuration&gt;</span>
        <span class="tag">&lt;/plugin&gt;</span>
    <span class="tag">&lt;/plugins&gt;</span>
<span class="tag">&lt;/build&gt;</span>
...</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are working with the Eclipse IDE, make sure to have a current version of the <a href="http://www.eclipse.org/m2e/">M2E plug-in</a>.
When importing a Maven project configured as shown above, it will set up the MapStruct annotation processor so it runs right in the IDE, whenever you save a mapper type.
Neat, isn&#8217;t it?</p>
</div>
<div class="paragraph">
<p>To double check that everything is working as expected, go to your project&#8217;s properties and select "Java Compiler" &#8594; "Annotation Processing" &#8594; "Factory Path".
The MapStruct processor JAR should be listed and enabled there.
Any processor options configured via the compiler plug-in (see below) should be listed under "Java Compiler" &#8594; "Annotation Processing".</p>
</div>
<div class="paragraph">
<p>If the processor is not kicking in, check that the configuration of annotation processors through M2E is enabled.
To do so, go to "Preferences" &#8594; "Maven" &#8594; "Annotation Processing" and select "Automatically configure JDT APT".
Alternatively, specify the following in the <code>properties</code> section of your POM file: <code>&lt;m2e.apt.activation&gt;jdt_apt&lt;/m2e.apt.activation&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Also make sure that your project is using Java 1.8 or later (project properties &#8594; "Java Compiler" &#8594; "Compile Compliance Level").
It will not work with older versions.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_gradle"><a class="anchor" href="#_gradle"></a>2.2. Gradle</h3>
<div class="paragraph">
<p>Add the following to your Gradle build file in order to enable MapStruct:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Gradle configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre>...
plugins {
    ...
    id <span class="string"><span class="delimiter">&quot;</span><span class="content">com.diffplug.eclipse.apt</span><span class="delimiter">&quot;</span></span> version <span class="string"><span class="delimiter">&quot;</span><span class="content">3.26.0</span><span class="delimiter">&quot;</span></span> <span class="comment">// Only for Eclipse</span>
}

dependencies {
    ...
    implementation <span class="string"><span class="delimiter">&quot;</span><span class="content">org.mapstruct:mapstruct:</span><span class="inline"><span class="inline-delimiter">${</span>mapstructVersion<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    annotationProcessor <span class="string"><span class="delimiter">&quot;</span><span class="content">org.mapstruct:mapstruct-processor:</span><span class="inline"><span class="inline-delimiter">${</span>mapstructVersion<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>

    <span class="comment">// If you are using mapstruct in test code</span>
    testAnnotationProcessor <span class="string"><span class="delimiter">&quot;</span><span class="content">org.mapstruct:mapstruct-processor:</span><span class="inline"><span class="inline-delimiter">${</span>mapstructVersion<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}
...</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can find a complete example in the <a href="https://github.com/mapstruct/mapstruct-examples/tree/master/mapstruct-on-gradle">mapstruct-examples</a> project on GitHub.</p>
</div>
</div>
<div class="sect2">
<h3 id="_apache_ant"><a class="anchor" href="#_apache_ant"></a>2.3. Apache Ant</h3>
<div class="paragraph">
<p>Add the <code>javac</code> task configured as follows to your <em>build.xml</em> file in order to enable MapStruct in your Ant-based project. Adjust the paths as required for your project layout.</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Ant configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>...
<span class="tag">&lt;javac</span>
    <span class="attribute-name">srcdir</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">src/main/java</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">destdir</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target/classes</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">classpath</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">path/to/mapstruct-1.4.2.Final.jar</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;compilerarg</span> <span class="attribute-name">line</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">-processorpath path/to/mapstruct-processor-1.4.2.Final.jar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;compilerarg</span> <span class="attribute-name">line</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">-s target/generated-sources</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/javac&gt;</span>
...</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can find a complete example in the <a href="https://github.com/mapstruct/mapstruct-examples/tree/master/mapstruct-on-ant">mapstruct-examples</a> project on GitHub.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration-options"><a class="anchor" href="#configuration-options"></a>2.4. Configuration options</h3>
<div class="paragraph">
<p>The MapStruct code generator can be configured using <em>annotation processor options</em>.</p>
</div>
<div class="paragraph">
<p>When invoking javac directly, these options are passed to the compiler in the form <em>-Akey=value</em>. When using MapStruct via Maven, any processor options can be passed using an <code>options</code> element within the configuration of the Maven processor plug-in like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. Maven configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td>
  <td class="code"><pre>...
<span class="tag">&lt;plugin&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>3.5.1<span class="tag">&lt;/version&gt;</span>
    <span class="tag">&lt;configuration&gt;</span>
        <span class="tag">&lt;source&gt;</span>1.8<span class="tag">&lt;/source&gt;</span>
        <span class="tag">&lt;target&gt;</span>1.8<span class="tag">&lt;/target&gt;</span>
        <span class="tag">&lt;annotationProcessorPaths&gt;</span>
            <span class="tag">&lt;path&gt;</span>
                <span class="tag">&lt;groupId&gt;</span>org.mapstruct<span class="tag">&lt;/groupId&gt;</span>
                <span class="tag">&lt;artifactId&gt;</span>mapstruct-processor<span class="tag">&lt;/artifactId&gt;</span>
                <span class="tag">&lt;version&gt;</span>${org.mapstruct.version}<span class="tag">&lt;/version&gt;</span>
            <span class="tag">&lt;/path&gt;</span>
        <span class="tag">&lt;/annotationProcessorPaths&gt;</span>
        <span class="comment">&lt;!-- due to problem in maven-compiler-plugin, for verbose mode add showWarnings --&gt;</span>
        <span class="tag">&lt;showWarnings&gt;</span>true<span class="tag">&lt;/showWarnings&gt;</span>
        <span class="tag">&lt;compilerArgs&gt;</span>
            <span class="tag">&lt;arg&gt;</span>
                -Amapstruct.suppressGeneratorTimestamp=true
            <span class="tag">&lt;/arg&gt;</span>
            <span class="tag">&lt;arg&gt;</span>
                -Amapstruct.suppressGeneratorVersionInfoComment=true
            <span class="tag">&lt;/arg&gt;</span>
            <span class="tag">&lt;arg&gt;</span>
                -Amapstruct.verbose=true
            <span class="tag">&lt;/arg&gt;</span>
        <span class="tag">&lt;/compilerArgs&gt;</span>
    <span class="tag">&lt;/configuration&gt;</span>
<span class="tag">&lt;/plugin&gt;</span>
...</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 5. Gradle configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>...
compileJava {
    options.compilerArgs += [
        <span class="string"><span class="delimiter">'</span><span class="content">-Amapstruct.suppressGeneratorTimestamp=true</span><span class="delimiter">'</span></span>,
        <span class="string"><span class="delimiter">'</span><span class="content">-Amapstruct.suppressGeneratorVersionInfoComment=true</span><span class="delimiter">'</span></span>,
        <span class="string"><span class="delimiter">'</span><span class="content">-Amapstruct.verbose=true</span><span class="delimiter">'</span></span>
    ]
}
...</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following options exist:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. MapStruct processor options</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Option</th>
<th class="tableblock halign-left valign-top">Purpose</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mapstruct.
suppressGeneratorTimestamp</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If set to <code>true</code>, the creation of a time stamp in the <code>@Generated</code> annotation in the generated mapper classes is suppressed.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mapstruct.verbose</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If set to <code>true</code>, MapStruct in which MapStruct logs its major decisions. Note, at the moment of writing in Maven, also <code>showWarnings</code> needs to be added due to a problem in the maven-compiler-plugin configuration.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mapstruct.
suppressGeneratorVersionInfoComment</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If set to <code>true</code>, the creation of the <code>comment</code> attribute in the <code>@Generated</code> annotation in the generated mapper classes is suppressed. The comment contains information about the version of MapStruct and about the compiler used for the annotation processing.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mapstruct.defaultComponentModel</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The name of the component model (see <a href="#retrieving-mapper">Retrieving a mapper</a>) based on which mappers should be generated.</p>
</div>
<div class="paragraph">
<p>Supported values are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>default</code>: the mapper uses no component model, instances are typically retrieved via <code>Mappers#getMapper(Class)</code></p>
</li>
<li>
<p><code>cdi</code>: the generated mapper is an application-scoped CDI bean and can be retrieved via <code>@Inject</code></p>
</li>
<li>
<p><code>spring</code>: the generated mapper is a singleton-scoped Spring bean and can be retrieved via <code>@Autowired</code></p>
</li>
<li>
<p><code>jsr330</code>: the generated mapper is annotated with {@code @Named} and can be retrieved via <code>@Inject</code>, e.g. using Spring</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a component model is given for a specific mapper via <code>@Mapper#componentModel()</code>, the value from the annotation takes precedence.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>default</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mapstruct.defaultInjectionStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The type of the injection in mapper via parameter <code>uses</code>. This is only used on annotated based component models
  such as CDI, Spring and JSR 330.</p>
</div>
<div class="paragraph">
<p>Supported values are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>field</code>: dependencies will be injected in fields</p>
</li>
<li>
<p><code>constructor</code>: will be generated constructor. Dependencies will be injected via constructor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When CDI <code>componentModel</code> a default constructor will also be generated.
If a injection strategy is given for a specific mapper via <code>@Mapper#injectionStrategy()</code>, the value from the annotation takes precedence over the option.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>field</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mapstruct.unmappedTargetPolicy</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The default reporting policy to be applied in case an attribute of the target object of a mapping method is not populated with a source value.</p>
</div>
<div class="paragraph">
<p>Supported values are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ERROR</code>: any unmapped target property will cause the mapping code generation to fail</p>
</li>
<li>
<p><code>WARN</code>: any unmapped target property will cause a warning at build time</p>
</li>
<li>
<p><code>IGNORE</code>: unmapped target properties are ignored</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a policy is given for a specific mapper via <code>@Mapper#unmappedTargetPolicy()</code>, the value from the annotation takes precedence.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WARN</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_using_mapstruct_on_java_9"><a class="anchor" href="#_using_mapstruct_on_java_9"></a>2.5. Using MapStruct on Java 9</h3>
<div class="paragraph">
<p>MapStruct can be used with Java 9 (JPMS), support for it is experimental.</p>
</div>
<div class="paragraph">
<p>A core theme of Java 9 is the modularization of the JDK. One effect of this is that a specific module needs	to be enabled for a project in order to use the <code>javax.annotation.Generated</code> annotation. <code>@Generated</code> is added by MapStruct to generated mapper classes to tag them as generated code, stating the date of generation, the generator version etc.</p>
</div>
<div class="paragraph">
<p>To allow usage of the <code>@Generated</code> annotation the module <em>java.xml.ws.annotation</em> must be enabled. When using Maven, this can be done like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>export MAVEN_OPTS="--add-modules java.xml.ws.annotation"</pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>@Generated</code> annotation is not available, MapStruct will detect this situation and not add it to generated mappers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In Java 9 <code>java.annotation.processing.Generated</code> was added (part of the <code>java.compiler</code> module),
if this annotation is available then it will be used.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="defining-mapper"><a class="anchor" href="#defining-mapper"></a>3. Defining a mapper</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section you&#8217;ll learn how to define a bean mapper with MapStruct and which options you have to do so.</p>
</div>
<div class="sect2">
<h3 id="basic-mappings"><a class="anchor" href="#basic-mappings"></a>3.1. Basic mappings</h3>
<div class="paragraph">
<p>To create a mapper simply define a Java interface with the required mapping method(s) and annotate it with the <code>org.mapstruct.Mapper</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. Java interface to define a mapper</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">make</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">manufacturer</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">numberOfSeats</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">seatCount</span><span class="delimiter">&quot;</span></span>)
    CarDto carToCarDto(Car car);

    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">fullName</span><span class="delimiter">&quot;</span></span>)
    PersonDto personToPersonDto(Person person);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@Mapper</code> annotation causes the MapStruct code generator to create an implementation of the <code>CarMapper</code> interface during build-time.</p>
</div>
<div class="paragraph">
<p>In the generated method implementations all readable properties from the source type (e.g. <code>Car</code>) will be copied into the corresponding property in the target type (e.g. <code>CarDto</code>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a property has the same name as its target entity counterpart, it will be mapped implicitly.</p>
</li>
<li>
<p>When a property has a different name in the target entity, its name can be specified via the <code>@Mapping</code> annotation.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The property name as defined in the <a href="http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html">JavaBeans specification</a> must be specified in the <code>@Mapping</code> annotation, e.g. <em>seatCount</em> for a property with the accessor methods <code>getSeatCount()</code> and <code>setSeatCount()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By means of the <code>@BeanMapping(ignoreByDefault = true)</code> the default behavior will be <strong>explicit mapping</strong>, meaning that all mappings have to be specified by means of the <code>@Mapping</code> and no warnings will be issued on missing target properties.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Fluent setters are also supported.
Fluent setters are setters that return the same type as the type being modified.</p>
</div>
<div class="paragraph">
<p>E.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>public Builder seatCount(int seatCount) {
    this.seatCount = seatCount;
    return this;
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To get a better understanding of what MapStruct does have a look at the following implementation of the <code>carToCarDto()</code> method as generated by MapStruct:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. Code generated by MapStruct</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td>
  <td class="code"><pre><span class="comment">// GENERATED CODE</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CarMapperImpl</span> <span class="directive">implements</span> CarMapper {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> CarDto carToCarDto(Car car) {
        <span class="keyword">if</span> ( car == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        CarDto carDto = <span class="keyword">new</span> CarDto();

        <span class="keyword">if</span> ( car.getFeatures() != <span class="predefined-constant">null</span> ) {
            carDto.setFeatures( <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">String</span>&gt;( car.getFeatures() ) );
        }
        carDto.setManufacturer( car.getMake() );
        carDto.setSeatCount( car.getNumberOfSeats() );
        carDto.setDriver( personToPersonDto( car.getDriver() ) );
        carDto.setPrice( <span class="predefined-type">String</span>.valueOf( car.getPrice() ) );
        <span class="keyword">if</span> ( car.getCategory() != <span class="predefined-constant">null</span> ) {
            carDto.setCategory( car.getCategory().toString() );
        }
        carDto.setEngine( engineToEngineDto( car.getEngine() ) );

        <span class="keyword">return</span> carDto;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> PersonDto personToPersonDto(Person person) {
        <span class="comment">//...</span>
    }

    <span class="directive">private</span> EngineDto engineToEngineDto(Engine engine) {
        <span class="keyword">if</span> ( engine == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        EngineDto engineDto = <span class="keyword">new</span> EngineDto();

        engineDto.setHorsePower(engine.getHorsePower());
        engineDto.setFuel(engine.getFuel());

        <span class="keyword">return</span> engineDto;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The general philosophy of MapStruct is to generate code which looks as much as possible as if you had written it yourself from hand. In particular this means that the values are copied from source to target by plain getter/setter invocations instead of reflection or similar.</p>
</div>
<div class="paragraph">
<p>As the example shows the generated code takes into account any name mappings specified via <code>@Mapping</code>.
If the type of a mapped attribute is different in source and target entity,
MapStruct will either apply an automatic conversion (as e.g. for the <em>price</em> property, see also <a href="#implicit-type-conversions">Implicit type conversions</a>)
or optionally invoke / create another mapping method (as e.g. for the <em>driver</em> / <em>engine</em> property, see also <a href="#mapping-object-references">Mapping object references</a>).
MapStruct will only create a new mapping method if and only if the source and target property are properties of a Bean and they themselves are Beans or simple properties.
i.e. they are not <code>Collection</code> or <code>Map</code> type properties.</p>
</div>
<div class="paragraph">
<p>Collection-typed attributes with the same element type will be copied by creating a new instance of the target collection type containing the elements from the source property. For collection-typed attributes with different element types each element will be mapped individually and added to the target collection (see <a href="#mapping-collections">Mapping collections</a>).</p>
</div>
<div class="paragraph">
<p>MapStruct takes all public properties of the source and target types into account. This includes properties declared on super-types.</p>
</div>
</div>
<div class="sect2">
<h3 id="mapping-composition"><a class="anchor" href="#mapping-composition"></a>3.2. Mapping Composition (experimental)</h3>
<div class="paragraph">
<p>MapStruct supports the use of meta annotations. The <code>@Mapping</code> annotation supports now <code>@Target</code> with <code>ElementType#ANNOTATION_TYPE</code> in addition to <code>ElementType#METHOD</code>. This allows <code>@Mapping</code> to be used on other (user defined) annotations for re-use purposes. For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.CLASS)
<span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>, ignore = <span class="predefined-constant">true</span>)
<span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">creationDate</span><span class="delimiter">&quot;</span></span>, expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">java(new java.util.Date())</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">groupName</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="annotation">@interface</span> ToEntity { }</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Can be used to characterise an <code>Entity</code> without the need to have a common base type. For instance, <code>ShelveEntity</code> and <code>BoxEntity</code> do not share a common base type in the <code>StorageMapper</code> below.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">StorageMapper</span> {

    StorageMapper INSTANCE = Mappers.getMapper( StorageMapper.class );

    <span class="annotation">@ToEntity</span>
    <span class="annotation">@Mapping</span>( target = <span class="string"><span class="delimiter">&quot;</span><span class="content">weightLimit</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">maxWeight</span><span class="delimiter">&quot;</span></span>)
    ShelveEntity map(ShelveDto source);

    <span class="annotation">@ToEntity</span>
    <span class="annotation">@Mapping</span>( target = <span class="string"><span class="delimiter">&quot;</span><span class="content">label</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">designation</span><span class="delimiter">&quot;</span></span>)
    BoxEntity map(BoxDto source);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Still, they do have some properties in common. The <code>@ToEntity</code> assumes both target beans <code>ShelveEntity</code> and <code>BoxEntity</code> have properties: <code>"id"</code>, <code>"creationDate"</code> and <code>"name"</code>. It furthermore assumes that the source beans <code>ShelveDto</code> and <code>BoxDto</code> always have a property <code>"groupName"</code>. This concept is also known as "duck-typing". In other words, if it quacks like duck, walks like a duck its probably a duck.</p>
</div>
<div class="paragraph">
<p>This feature is still experimental. Error messages are not mature yet: the method on which the problem occurs is displayed, as well as the concerned values in the <code>@Mapping</code> annotation. However, the composition aspect is not visible. The messages are "as if" the <code>@Mapping</code> would be present on the concerned method directly.
Therefore, the user should use this feature with care, especially when uncertain when a property is always present.</p>
</div>
<div class="paragraph">
<p>A more typesafe (but also more verbose) way would be to define base classes / interfaces on the target bean and the source bean and use <code>@InheritConfiguration</code> to achieve the same result (see <a href="#mapping-configuration-inheritance">Mapping configuration inheritance</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="adding-custom-methods"><a class="anchor" href="#adding-custom-methods"></a>3.3. Adding custom methods to mappers</h3>
<div class="paragraph">
<p>In some cases it can be required to manually implement a specific mapping from one type to another which can&#8217;t be generated by MapStruct. One way to handle this is to implement the custom method on another class which then is used by mappers generated by MapStruct (see <a href="#invoking-other-mappers">Invoking other mappers</a>).</p>
</div>
<div class="paragraph">
<p>Alternatively, when using Java 8 or later, you can implement custom methods directly in a mapper interface as default methods. The generated code will invoke the default methods if the argument and return types match.</p>
</div>
<div class="paragraph">
<p>As an example let&#8217;s assume the mapping from <code>Person</code> to <code>PersonDto</code> requires some special logic which can&#8217;t be generated by MapStruct. You could then define the mapper from the previous example like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. Mapper which defines a custom mapping with a default method</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    <span class="annotation">@Mapping</span>(...)
    ...
    CarDto carToCarDto(Car car);

    <span class="keyword">default</span> PersonDto personToPersonDto(Person person) {
        <span class="comment">//hand-written mapping logic</span>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The class generated by MapStruct implements the method <code>carToCarDto()</code>. The generated code in <code>carToCarDto()</code> will invoke the manually implemented <code>personToPersonDto()</code> method when mapping the <code>driver</code> attribute.</p>
</div>
<div class="paragraph">
<p>A mapper could also be defined in the form of an abstract class instead of an interface and implement the custom methods directly in the mapper class. In this case MapStruct will generate an extension of the abstract class with implementations of all abstract methods. An advantage of this approach over declaring default methods is that additional fields could be declared in the mapper class.</p>
</div>
<div class="paragraph">
<p>The previous example where the mapping from <code>Person</code> to <code>PersonDto</code> requires some special logic could then be defined like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. Mapper defined by an abstract class</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CarMapper</span> {

    <span class="annotation">@Mapping</span>(...)
    ...
    public <span class="directive">abstract</span> CarDto carToCarDto(Car car);

    <span class="directive">public</span> PersonDto personToPersonDto(Person person) {
        <span class="comment">//hand-written mapping logic</span>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>MapStruct will generate a sub-class of <code>CarMapper</code> with an implementation of the <code>carToCarDto()</code> method as it is declared abstract. The generated code in <code>carToCarDto()</code> will invoke the manually implemented <code>personToPersonDto()</code> method when mapping the <code>driver</code> attribute.</p>
</div>
</div>
<div class="sect2">
<h3 id="mappings-with-several-source-parameters"><a class="anchor" href="#mappings-with-several-source-parameters"></a>3.4. Mapping methods with several source parameters</h3>
<div class="paragraph">
<p>MapStruct also supports mapping methods with several source parameters. This is useful e.g. in order to combine several entities into one data transfer object. The following shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. Mapping method with several source parameters</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">AddressMapper</span> {

    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">person.description</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">description</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">address.houseNo</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">houseNumber</span><span class="delimiter">&quot;</span></span>)
    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The shown mapping method takes two source parameters and returns a combined target object. As with single-parameter mapping methods properties are mapped by name.</p>
</div>
<div class="paragraph">
<p>In case several source objects define a property with the same name, the source parameter from which to retrieve the property must be specified using the <code>@Mapping</code> annotation as shown for the <code>description</code> property in the example. An error will be raised when such an ambiguity is not resolved. For properties which only exist once in the given source objects it is optional to specify the source parameter&#8217;s name as it can be determined automatically.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Specifying the parameter in which the property resides is mandatory when using the <code>@Mapping</code> annotation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Mapping methods with several source parameters will return <code>null</code> in case all the source parameters are <code>null</code>. Otherwise the target object will be instantiated and all properties from the provided parameters will be propagated.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>MapStruct also offers the possibility to directly refer to a source parameter.</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Mapping method directly referring to a source parameter</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">AddressMapper</span> {

    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">person.description</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">description</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">hn</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">houseNumber</span><span class="delimiter">&quot;</span></span>)
    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, <span class="predefined-type">Integer</span> hn);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case the source parameter is directly mapped into the target as the example above demonstrates. The parameter <code>hn</code>, a non bean type (in this case <code>java.lang.Integer</code>) is mapped to <code>houseNumber</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mapping-nested-bean-properties-to-current-target"><a class="anchor" href="#mapping-nested-bean-properties-to-current-target"></a>3.5. Mapping nested bean properties to current target</h3>
<div class="paragraph">
<p>If you don&#8217;t want explicitly name all properties from nested source bean, you can use <code>.</code> as target.
 This will tell MapStruct to map every property from source bean to target object. The following shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. use of "target this" annotation "."</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre> <span class="annotation">@Mapper</span>
 <span class="directive">public</span> <span class="type">interface</span> <span class="class">CustomerMapper</span> {

     <span class="annotation">@Mapping</span>( target = <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">record.name</span><span class="delimiter">&quot;</span></span> )
     <span class="annotation">@Mapping</span>( target = <span class="string"><span class="delimiter">&quot;</span><span class="content">.</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">record</span><span class="delimiter">&quot;</span></span> )
     <span class="annotation">@Mapping</span>( target = <span class="string"><span class="delimiter">&quot;</span><span class="content">.</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">account</span><span class="delimiter">&quot;</span></span> )
     Customer customerDtoToCustomer(CustomerDto customerDto);
 }</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The generated code will map every property from <code>CustomerDto.record</code> to <code>Customer</code> directly, without need to manually name any of them.
The same goes for <code>Customer.account</code>.</p>
</div>
<div class="paragraph">
<p>When there are conflicts, these can be resolved by explicitely defining the mapping. For instance in the example above. <code>name</code> occurs in <code>CustomerDto.record</code> and in <code>CustomerDto.account</code>. The mapping <code>@Mapping( target = "name", source = "record.name" )</code> resolves this conflict.</p>
</div>
<div class="paragraph">
<p>This "target this" notation can be very useful when mapping hierarchical objects to flat objects and vice versa (<code>@InheritInverseConfiguration</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="updating-bean-instances"><a class="anchor" href="#updating-bean-instances"></a>3.6. Updating existing bean instances</h3>
<div class="paragraph">
<p>In some cases you need mappings which don&#8217;t create a new instance of the target type but instead update an existing instance of that type. This sort of mapping can be realized by adding a parameter for the target object and marking this parameter with <code>@MappingTarget</code>. The following shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. Update method</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    <span class="type">void</span> updateCarFromDto(CarDto carDto, <span class="annotation">@MappingTarget</span> Car car);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The generated code of the <code>updateCarFromDto()</code> method will update the passed <code>Car</code> instance with the properties from the given <code>CarDto</code> object. There may be only one parameter marked as mapping target. Instead of <code>void</code> you may also set the method&#8217;s return type to the type of the target parameter, which will cause the generated implementation to update the passed mapping target and return it as well. This allows for fluent invocations of mapping methods.</p>
</div>
<div class="paragraph">
<p>For <code>CollectionMappingStrategy.ACCESSOR_ONLY</code> Collection- or map-typed properties of the target bean to be updated will be cleared and then populated with the values from the corresponding source collection or map. Otherwise, For <code>CollectionMappingStrategy.ADDER_PREFERRED</code> or <code>CollectionMappingStrategy.TARGET_IMMUTABLE</code> the target will not be cleared and the values will be populated immediately.</p>
</div>
</div>
<div class="sect2">
<h3 id="direct-field-mappings"><a class="anchor" href="#direct-field-mappings"></a>3.7. Mappings with direct field access</h3>
<div class="paragraph">
<p>MapStruct also supports mappings of <code>public</code> fields that have no getters/setters. MapStruct will
use the fields as read/write accessor if it cannot find suitable getter/setter methods for the property.</p>
</div>
<div class="paragraph">
<p>A field is considered as a read accessor if it is <code>public</code> or <code>public final</code>. If a field is <code>static</code> it is not
considered as a read accessor.</p>
</div>
<div class="paragraph">
<p>A field is considered as a write accessor only if it is <code>public</code>. If a field is <code>final</code> and/or <code>static</code> it is not
considered as a write accessor.</p>
</div>
<div class="paragraph">
<p>Small example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. Example classes for mapping</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">Customer</span> {

    <span class="directive">private</span> <span class="predefined-type">Long</span> id;
    <span class="directive">private</span> <span class="predefined-type">String</span> name;

    <span class="comment">//getters and setter omitted for brevity</span>
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">CustomerDto</span> {

    <span class="directive">public</span> <span class="predefined-type">Long</span> id;
    <span class="directive">public</span> <span class="predefined-type">String</span> customerName;
}

<span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CustomerMapper</span> {

    CustomerMapper INSTANCE = Mappers.getMapper( CustomerMapper.class );

    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">customerName</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)
    Customer toCustomer(CustomerDto customerDto);

    <span class="annotation">@InheritInverseConfiguration</span>
    CustomerDto fromCustomer(Customer customer);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For the configuration from above, the generated mapper looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. Generated mapper for example classes</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="comment">// GENERATED CODE</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CustomerMapperImpl</span> <span class="directive">implements</span> CustomerMapper {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Customer toCustomer(CustomerDto customerDto) {
        <span class="comment">// ...</span>
        customer.setId( customerDto.id );
        customer.setName( customerDto.customerName );
        <span class="comment">// ...</span>
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> CustomerDto fromCustomer(Customer customer) {
        <span class="comment">// ...</span>
        customerDto.id = customer.getId();
        customerDto.customerName = customer.getName();
        <span class="comment">// ...</span>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can find the complete example in the
<a href="https://github.com/mapstruct/mapstruct-examples/tree/master/mapstruct-field-mapping">mapstruct-examples-field-mapping</a>
project on GitHub.</p>
</div>
</div>
<div class="sect2">
<h3 id="mapping-with-builders"><a class="anchor" href="#mapping-with-builders"></a>3.8. Using builders</h3>
<div class="paragraph">
<p>MapStruct also supports mapping of immutable types via builders.
When performing a mapping MapStruct checks if there is a builder for the type being mapped.
This is done via the <code>BuilderProvider</code> SPI.
If a Builder exists for a certain type, then that builder will be used for the mappings.</p>
</div>
<div class="paragraph">
<p>The default implementation of the <code>BuilderProvider</code> assumes the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The type has a parameterless public static builder creation method that returns a builder.
So for example <code>Person</code> has a public static method that returns <code>PersonBuilder</code>.</p>
</li>
<li>
<p>The builder type has a parameterless public method (build method) that returns the type being built.
In our example <code>PersonBuilder</code> has a method returning <code>Person</code>.</p>
</li>
<li>
<p>In case there are multiple build methods, MapStruct will look for a method called <code>build</code>, if such method exists
then this would be used, otherwise a compilation error would be created.</p>
</li>
<li>
<p>A specific build method can be defined by using <code>@Builder</code> within: <code>@BeanMapping</code>, <code>@Mapper</code> or <code>@MapperConfig</code></p>
</li>
<li>
<p>In case there are multiple builder creation methods that satisfy the above conditions then a <code>MoreThanOneBuilderCreationMethodException</code>
will be thrown from the <code>DefaultBuilderProvider</code> SPI.
In case of a <code>MoreThanOneBuilderCreationMethodException</code> MapStruct will write a warning in the compilation and not use any builder.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If such type is found then MapStruct will use that type to perform the mapping to (i.e. it will look for setters into that type).
To finish the mapping MapStruct generates code that will invoke the build method of the builder.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Builder detection can be switched off by means of <code>@Builder#disableBuilder</code>. MapStruct will fall back on regular getters / setters in case builders are disabled.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <a href="#object-factories">Object factories</a> are also considered for the builder type.
E.g. If an object factory exists for our <code>PersonBuilder</code> then this factory would be used instead of the builder creation method.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 16. Person with Builder example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> name;

    <span class="directive">protected</span> Person(Person.Builder builder) {
        <span class="local-variable">this</span>.name = builder.name;
    }

    <span class="directive">public</span> <span class="directive">static</span> Person.Builder builder() {
        <span class="keyword">return</span> <span class="keyword">new</span> Person.Builder();
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">Builder</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;

        <span class="directive">public</span> Builder name(<span class="predefined-type">String</span> name) {
            <span class="local-variable">this</span>.name = name;
            <span class="keyword">return</span> <span class="local-variable">this</span>;
        }

        <span class="directive">public</span> Person create() {
            <span class="keyword">return</span> <span class="keyword">new</span> Person( <span class="local-variable">this</span> );
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 17. Person Mapper definition</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">interface</span> <span class="class">PersonMapper</span> {

    Person map(PersonDto dto);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 18. Generated mapper with builder</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="comment">// GENERATED CODE</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">PersonMapperImpl</span> <span class="directive">implements</span> PersonMapper {

    <span class="directive">public</span> Person map(PersonDto dto) {
        <span class="keyword">if</span> (dto == <span class="predefined-constant">null</span>) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        Person.Builder builder = Person.builder();

        builder.name( dto.getName() );

        <span class="keyword">return</span> builder.create();
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Supported builder frameworks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://projectlombok.org/">Lombok</a> - It is required to have the Lombok classes in a separate module.
See for more information at <a href="https://github.com/rzwitserloot/lombok/issues/1538">rzwitserloot/lombok#1538</a> and to set up Lombok with MapStruct, refer to <a href="#lombok">Lombok</a>.</p>
</li>
<li>
<p><a href="https://github.com/google/auto/blob/master/value/userguide/index.md">AutoValue</a></p>
</li>
<li>
<p><a href="https://immutables.github.io/">Immutables</a> - When Immutables are present on the annotation processor path then the <code>ImmutablesAccessorNamingStrategy</code> and <code>ImmutablesBuilderProvider</code> would be used by default</p>
</li>
<li>
<p><a href="https://github.com/google/FreeBuilder">FreeBuilder</a> - When FreeBuilder is present on the annotation processor path then the <code>FreeBuilderAccessorNamingStrategy</code> would be used by default.
When using FreeBuilder then the JavaBean convention should be followed, otherwise MapStruct won&#8217;t recognize the fluent getters.</p>
</li>
<li>
<p>It also works for custom builders (handwritten ones) if the implementation supports the defined rules for the default <code>BuilderProvider</code>.
Otherwise, you would need to write a custom <code>BuilderProvider</code></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In case you want to disable using builders then you can use the <code>NoOpBuilderProvider</code> by creating a <code>org.mapstruct.ap.spi.BuilderProvider</code> file in the <code>META-INF/services</code> directory with <code>org.mapstruct.ap.spi.NoOpBuilderProvider</code> as it&#8217;s content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mapping-with-constructors"><a class="anchor" href="#mapping-with-constructors"></a>3.9. Using Constructors</h3>
<div class="paragraph">
<p>MapStruct supports using constructors for mapping target types.
When doing a mapping MapStruct checks if there is a builder for the type being mapped.
If there is no builder, then MapStruct looks for a single accessible constructor.
When there are multiple constructors then the following is done to pick the one which should be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a constructor is annotated with an annotation <em>named</em> <code>@Default</code> (from any package, see <a href="#non-shipped-annotations">Non-shipped annotations</a>) it will be used.</p>
</li>
<li>
<p>If a single public constructor exists then it will be used to construct the object, and the other non public constructors will be ignored.</p>
</li>
<li>
<p>If a parameterless constructor exists then it will be used to construct the object, and the other constructors will be ignored.</p>
</li>
<li>
<p>If there are multiple eligible constructors then there will be a compilation error due to ambiguous constructors. In order to break the ambiguity an annotation <em>named</em> <code>@Default</code> (from any package, see <a href="#non-shipped-annotations">Non-shipped annotations</a>) can used.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 19. Deciding which constructor to use</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">Vehicle</span> {

    <span class="directive">protected</span> Vehicle() { }

    <span class="comment">// MapStruct will use this constructor, because it is a single public constructor</span>
    <span class="directive">public</span> Vehicle(<span class="predefined-type">String</span> color) { }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Car</span> {

    <span class="comment">// MapStruct will use this constructor, because it is a parameterless empty constructor</span>
    <span class="directive">public</span> Car() { }

    <span class="directive">public</span> Car(<span class="predefined-type">String</span> make, <span class="predefined-type">String</span> color) { }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Truck</span> {

    <span class="directive">public</span> Truck() { }

    <span class="comment">// MapStruct will use this constructor, because it is annotated with @Default</span>
    <span class="annotation">@Default</span>
    <span class="directive">public</span> Truck(<span class="predefined-type">String</span> make, <span class="predefined-type">String</span> color) { }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Van</span> {

    <span class="comment">// There will be a compilation error when using this class because MapStruct cannot pick a constructor</span>

    <span class="directive">public</span> Van(<span class="predefined-type">String</span> make) { }

    <span class="directive">public</span> Van(<span class="predefined-type">String</span> make, <span class="predefined-type">String</span> color) { }

}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When using a constructor then the names of the parameters of the constructor will be used and matched to the target properties.
When the constructor has an annotation <em>named</em> <code>@ConstructorProperties</code> (from any package, see <a href="#non-shipped-annotations">Non-shipped annotations</a>) then this annotation will be used to get the names of the parameters.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When an object factory method or a method annotated with <code>@ObjectFactory</code> exists, it will take precedence over any constructor defined in the target.
The target object constructor will not be used in that case.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 20. Person with constructor parameters</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> name;
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> surname;

    <span class="directive">public</span> Person(<span class="predefined-type">String</span> name, <span class="predefined-type">String</span> surname) {
        <span class="local-variable">this</span>.name = name;
        <span class="local-variable">this</span>.surname = surname;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 21. Person With Constructor Mapper definition</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">interface</span> <span class="class">PersonMapper</span> {

    Person map(PersonDto dto);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 22. Generated mapper with constructor</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td>
  <td class="code"><pre><span class="comment">// GENERATED CODE</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">PersonMapperImpl</span> <span class="directive">implements</span> PersonMapper {

    <span class="directive">public</span> Person map(PersonDto dto) {
        <span class="keyword">if</span> (dto == <span class="predefined-constant">null</span>) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        <span class="predefined-type">String</span> name;
        <span class="predefined-type">String</span> surname;
        name = dto.getName();
        surname = dto.getSurname();

        Person person = <span class="keyword">new</span> Person( name, surname );

        <span class="keyword">return</span> person;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="retrieving-mapper"><a class="anchor" href="#retrieving-mapper"></a>4. Retrieving a mapper</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="mappers-factory"><a class="anchor" href="#mappers-factory"></a>4.1. The Mappers factory (no dependency injection)</h3>
<div class="paragraph">
<p>When not using a DI framework, Mapper instances can be retrieved via the <code>org.mapstruct.factory.Mappers</code> class. Just invoke the <code>getMapper()</code> method, passing the interface type of the mapper to return:</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. Using the Mappers factory</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>CarMapper mapper = Mappers.getMapper( CarMapper.class );</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By convention, a mapper interface should define a member called <code>INSTANCE</code> which holds a single instance of the mapper type:</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. Declaring an instance of a mapper (interface)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    CarMapper INSTANCE = Mappers.getMapper( CarMapper.class );

    CarDto carToCarDto(Car car);
}
</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 25. Declaring an instance of a mapper (abstract class)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CarMapper</span> {

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> CarMapper INSTANCE = Mappers.getMapper( CarMapper.class );

    CarDto carToCarDto(Car car);
}
</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This pattern makes it very easy for clients to use mapper objects without repeatedly instantiating new instances:</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. Accessing a mapper</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>Car car = ...;
CarDto dto = CarMapper.INSTANCE.carToCarDto( car );</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that mappers generated by MapStruct are stateless and thread-safe and thus can safely be accessed from several threads at the same time.</p>
</div>
</div>
<div class="sect2">
<h3 id="using-dependency-injection"><a class="anchor" href="#using-dependency-injection"></a>4.2. Using dependency injection</h3>
<div class="paragraph">
<p>If you&#8217;re working with a dependency injection framework such as <a href="http://jcp.org/en/jsr/detail?id=346">CDI</a> (Contexts and Dependency Injection for Java<sup>TM</sup> EE) or the <a href="http://www.springsource.org/spring-framework">Spring Framework</a>, it is recommended to obtain mapper objects via dependency injection and <strong>not</strong> via the <code>Mappers</code> class as described above. For that purpose you can specify the component model which generated mapper classes should be based on either via <code>@Mapper#componentModel</code> or using a processor option as described in <a href="#configuration-options">Configuration options</a>.</p>
</div>
<div class="paragraph">
<p>Currently there is support for CDI and Spring (the latter either via its custom annotations or using the JSR 330 annotations). See <a href="#configuration-options">Configuration options</a> for the allowed values of the <code>componentModel</code> attribute which are the same as for the <code>mapstruct.defaultComponentModel</code> processor option. In both cases the required annotations will be added to the generated mapper implementations classes in order to make the same subject to dependency injection. The following shows an example using CDI:</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. A mapper using the CDI component model</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>(componentModel = <span class="string"><span class="delimiter">&quot;</span><span class="content">cdi</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    CarDto carToCarDto(Car car);
}
</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The generated mapper implementation will be marked with the <code>@ApplicationScoped</code> annotation and thus can be injected into fields, constructor arguments etc. using the <code>@Inject</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. Obtaining a mapper via dependency injection</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="annotation">@Inject</span>
<span class="directive">private</span> CarMapper mapper;</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A mapper which uses other mapper classes (see <a href="#invoking-other-mappers">Invoking other mappers</a>) will obtain these mappers using the configured component model. So if <code>CarMapper</code> from the previous example was using another mapper, this other mapper would have to be an injectable CDI bean as well.</p>
</div>
</div>
<div class="sect2">
<h3 id="injection-strategy"><a class="anchor" href="#injection-strategy"></a>4.3. Injection strategy</h3>
<div class="paragraph">
<p>When using <a href="#using-dependency-injection">dependency injection</a>, you can choose between field and constructor injection.
This can be done by either providing the injection strategy via <code>@Mapper</code> or <code>@MapperConfig</code> annotation.</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. Using constructor injection</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>(componentModel = <span class="string"><span class="delimiter">&quot;</span><span class="content">cdi</span><span class="delimiter">&quot;</span></span>, uses = EngineMapper.class, injectionStrategy = InjectionStrategy.CONSTRUCTOR)
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {
    CarDto carToCarDto(Car car);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The generated mapper will inject all classes defined in the <strong>uses</strong> attribute.
When <code>InjectionStrategy#CONSTRUCTOR</code> is used, the constructor will have the appropriate annotation and the fields won&#8217;t.
When <code>InjectionStrategy#FIELD</code> is used, the annotation is on the field itself.
For now, the default injection strategy is field injection, but it can be configured with <a href="#configuration-options">Configuration options</a>.
It is recommended to use constructor injection to simplify testing.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For abstract classes or decorators setter injection should be used.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="datatype-conversions"><a class="anchor" href="#datatype-conversions"></a>5. Data type conversions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Not always a mapped attribute has the same type in the source and target objects. For instance an attribute may be of type <code>int</code> in the source bean but of type <code>Long</code> in the target bean.</p>
</div>
<div class="paragraph">
<p>Another example are references to other objects which should be mapped to the corresponding types in the target model. E.g. the class <code>Car</code> might have a property <code>driver</code> of the type <code>Person</code> which needs to be converted into a <code>PersonDto</code> object when mapping a <code>Car</code> object.</p>
</div>
<div class="paragraph">
<p>In this section you&#8217;ll learn how MapStruct deals with such data type conversions.</p>
</div>
<div class="sect2">
<h3 id="implicit-type-conversions"><a class="anchor" href="#implicit-type-conversions"></a>5.1. Implicit type conversions</h3>
<div class="paragraph">
<p>MapStruct takes care of type conversions automatically in many cases. If for instance an attribute is of type <code>int</code> in the source bean but of type <code>String</code> in the target bean, the generated code will transparently perform a conversion by calling <code>String#valueOf(int)</code> and <code>Integer#parseInt(String)</code>, respectively.</p>
</div>
<div class="paragraph">
<p>Currently the following conversions are applied automatically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Between all Java primitive data types and their corresponding wrapper types, e.g. between <code>int</code> and <code>Integer</code>, <code>boolean</code> and <code>Boolean</code> etc. The generated code is <code>null</code> aware, i.e. when converting a wrapper type into the corresponding primitive type a <code>null</code> check will be performed.</p>
</li>
<li>
<p>Between all Java primitive number types and the wrapper types, e.g. between <code>int</code> and <code>long</code> or <code>byte</code> and <code>Integer</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Converting from larger data types to smaller ones (e.g. from <code>long</code> to <code>int</code>) can cause a value or precision loss. The <code>Mapper</code> and <code>MapperConfig</code> annotations have a method <code>typeConversionPolicy</code> to control warnings / errors. Due to backward compatibility reasons the default value is 'ReportingPolicy.IGNORE`.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Between all Java primitive types (including their wrappers) and <code>String</code>, e.g. between <code>int</code> and <code>String</code> or <code>Boolean</code> and <code>String</code>. A format string as understood by <code>java.text.DecimalFormat</code> can be specified.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 30. Conversion from int to String</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span>, numberFormat = <span class="string"><span class="delimiter">&quot;</span><span class="content">$#.00</span><span class="delimiter">&quot;</span></span>)
    CarDto carToCarDto(Car car);

    <span class="annotation">@IterableMapping</span>(numberFormat = <span class="string"><span class="delimiter">&quot;</span><span class="content">$#.00</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; prices(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; prices);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Between <code>enum</code> types and <code>String</code>.</p>
</li>
<li>
<p>Between big number types (<code>java.math.BigInteger</code>, <code>java.math.BigDecimal</code>) and Java primitive types (including their wrappers) as well as String. A format string as understood by <code>java.text.DecimalFormat</code> can be specified.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 31. Conversion from BigDecimal to String</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">power</span><span class="delimiter">&quot;</span></span>, numberFormat = <span class="string"><span class="delimiter">&quot;</span><span class="content">#.##E0</span><span class="delimiter">&quot;</span></span>)
    CarDto carToCarDto(Car car);

}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Between <code>JAXBElement&lt;T&gt;</code> and <code>T</code>, <code>List&lt;JAXBElement&lt;T&gt;&gt;</code> and <code>List&lt;T&gt;</code></p>
</li>
<li>
<p>Between <code>java.util.Calendar</code>/<code>java.util.Date</code> and JAXB&#8217;s <code>XMLGregorianCalendar</code></p>
</li>
<li>
<p>Between <code>java.util.Date</code>/<code>XMLGregorianCalendar</code> and <code>String</code>. A format string as understood by <code>java.text.SimpleDateFormat</code> can be specified via the <code>dateFormat</code> option as this:</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 32. Conversion from Date to String</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">manufacturingDate</span><span class="delimiter">&quot;</span></span>, dateFormat = <span class="string"><span class="delimiter">&quot;</span><span class="content">dd.MM.yyyy</span><span class="delimiter">&quot;</span></span>)
    CarDto carToCarDto(Car car);

    <span class="annotation">@IterableMapping</span>(dateFormat = <span class="string"><span class="delimiter">&quot;</span><span class="content">dd.MM.yyyy</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; stringListToDateList(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Date</span>&gt; dates);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Between Jodas <code>org.joda.time.DateTime</code>, <code>org.joda.time.LocalDateTime</code>, <code>org.joda.time.LocalDate</code>, <code>org.joda.time.LocalTime</code> and <code>String</code>. A format string as understood by <code>java.text.SimpleDateFormat</code> can be specified via the <code>dateFormat</code> option (see above).</p>
</li>
<li>
<p>Between Jodas <code>org.joda.time.DateTime</code> and  <code>javax.xml.datatype.XMLGregorianCalendar</code>, <code>java.util.Calendar</code>.</p>
</li>
<li>
<p>Between Jodas <code>org.joda.time.LocalDateTime</code>, <code>org.joda.time.LocalDate</code> and <code>javax.xml.datatype.XMLGregorianCalendar</code>, <code>java.util.Date</code>.</p>
</li>
<li>
<p>Between <code>java.time.LocalDate</code>, <code>java.time.LocalDateTime</code> and <code>javax.xml.datatype.XMLGregorianCalendar</code>.</p>
</li>
<li>
<p>Between <code>java.time.ZonedDateTime</code>, <code>java.time.LocalDateTime</code>, <code>java.time.LocalDate</code>, <code>java.time.LocalTime</code> from Java 8 Date-Time package and <code>String</code>. A format string as understood by <code>java.text.SimpleDateFormat</code> can be specified via the <code>dateFormat</code> option (see above).</p>
</li>
<li>
<p>Between <code>java.time.Instant</code>, <code>java.time.Duration</code>, <code>java.time.Period</code> from Java 8 Date-Time package and <code>String</code> using the <code>parse</code> method in each class to map from <code>String</code> and using <code>toString</code> to map into <code>String</code>.</p>
</li>
<li>
<p>Between <code>java.time.ZonedDateTime</code> from Java 8 Date-Time package and <code>java.util.Date</code> where, when mapping a <code>ZonedDateTime</code> from a given <code>Date</code>, the system default timezone is used.</p>
</li>
<li>
<p>Between <code>java.time.LocalDateTime</code> from Java 8 Date-Time package and <code>java.util.Date</code> where timezone UTC is used as the timezone.</p>
</li>
<li>
<p>Between <code>java.time.LocalDate</code> from Java 8 Date-Time package and <code>java.util.Date</code> / <code>java.sql.Date</code> where timezone UTC is used as the timezone.</p>
</li>
<li>
<p>Between <code>java.time.Instant</code> from Java 8 Date-Time package and <code>java.util.Date</code>.</p>
</li>
<li>
<p>Between <code>java.time.ZonedDateTime</code> from Java 8 Date-Time package and <code>java.util.Calendar</code>.</p>
</li>
<li>
<p>Between <code>java.sql.Date</code> and <code>java.util.Date</code></p>
</li>
<li>
<p>Between <code>java.sql.Time</code> and <code>java.util.Date</code></p>
</li>
<li>
<p>Between <code>java.sql.Timestamp</code> and <code>java.util.Date</code></p>
</li>
<li>
<p>When converting from a <code>String</code>, omitting <code>Mapping#dateFormat</code>, it leads to usage of the default pattern and date format symbols for the default locale. An exception to this rule is <code>XmlGregorianCalendar</code> which results in parsing the <code>String</code> according to <a href="http://www.w3.org/TR/xmlschema-2/#dateTime">XML Schema 1.0 Part 2, Section 3.2.7-14.1, Lexical Representation</a>.</p>
</li>
<li>
<p>Between <code>java.util.Currency</code> and <code>String</code>.</p>
<div class="ulist">
<ul>
<li>
<p>When converting from a <code>String</code>, the value needs to be a valid <a href="https://en.wikipedia.org/wiki/ISO_4217">ISO-4217</a> alphabetic code otherwise an <code>IllegalArgumentException</code> is thrown</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="mapping-object-references"><a class="anchor" href="#mapping-object-references"></a>5.2. Mapping object references</h3>
<div class="paragraph">
<p>Typically an object has not only primitive attributes but also references other objects. E.g. the <code>Car</code> class could contain a reference to a <code>Person</code> object (representing the car&#8217;s driver) which should be mapped to a <code>PersonDto</code> object referenced by the <code>CarDto</code> class.</p>
</div>
<div class="paragraph">
<p>In this case just define a mapping method for the referenced object type as well:</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. Mapper with one mapping method using another</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    CarDto carToCarDto(Car car);

    PersonDto personToPersonDto(Person person);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The generated code for the <code>carToCarDto()</code> method will invoke the <code>personToPersonDto()</code> method for mapping the <code>driver</code> attribute, while the generated implementation for <code>personToPersonDto()</code> performs the mapping of person objects.</p>
</div>
<div class="paragraph">
<p>That way it is possible to map arbitrary deep object graphs. When mapping from entities into data transfer objects it is often useful to cut references to other entities at a certain point. To do so, implement a custom mapping method (see the next section) which e.g. maps a referenced entity to its id in the target object.</p>
</div>
<div class="paragraph">
<p>When generating the implementation of a mapping method, MapStruct will apply the following routine for each attribute pair in the source and target object:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If source and target attribute have the same type, the value will be simply copied <strong>direct</strong> from source to target. If the attribute is a collection (e.g. a <code>List</code>) a copy of the collection will be set into the target attribute.</p>
</li>
<li>
<p>If source and target attribute type differ, check whether there is another <strong>mapping method</strong> which has the type of the source attribute as parameter type and the type of the target attribute as return type. If such a method exists it will be invoked in the generated mapping implementation.</p>
</li>
<li>
<p>If no such method exists MapStruct will look whether a <strong>built-in conversion</strong> for the source and target type of the attribute exists. If this is the case, the generated mapping code will apply this conversion.</p>
</li>
<li>
<p>If no such method exists MapStruct will apply <strong>complex</strong> conversions:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>mapping method, the result mapped by mapping method, like this: <code>target = method1( method2( source ) )</code></p>
</li>
<li>
<p>built-in conversion, the result mapped by mapping method, like this: <code>target = method( conversion( source ) )</code></p>
</li>
<li>
<p>mapping method, the result mapped by build-in conversion, like this: <code>target = conversion( method( source ) )</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>If no such method was found MapStruct will try to generate an automatic sub-mapping method that will do the mapping between the source and target attributes.</p>
</li>
<li>
<p>If MapStruct could not create a name based mapping method an error will be raised at build time, indicating the non-mappable attribute and its path.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A mapping control (<code>MappingControl</code>) can be defined on all levels (<code>@MapperConfig</code>, <code>@Mapper</code>, <code>@BeanMapping</code>, <code>@Mapping</code>), the latter taking precedence over the former. For example: <code>@Mapper( mappingControl = NoComplexMapping.class )</code> takes precedence over <code>@MapperConfig( mappingControl = DeepClone.class )</code>. <code>@IterableMapping</code> and <code>@MapMapping</code> work similar as <code>@Mapping</code>. MappingControl is experimental from MapStruct 1.4.
<code>MappingControl</code> has an enum that corresponds to the first 4 options above: <code>MappingControl.Use#DIRECT</code>, <code>MappingControl.Use#MAPPING_METHOD</code>, <code>MappingControl.Use#BUILT_IN_CONVERSION</code> and <code>MappingControl.Use#COMPLEX_MAPPING</code> the presence of which allows the user to switch <strong>on</strong> a option. The absence of an enum switches <strong>off</strong> a mapping option. Default they are all present enabling all mapping options.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In order to stop MapStruct from generating automatic sub-mapping methods as in 5. above, one can use <code>@Mapper( disableSubMappingMethodsGeneration = true )</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The user has full control over the mapping by means of meta annotations. Some handy ones have been defined such as <code>@DeepClone</code> which only allows direct mappings. The result: if source and target type are the same, MapStruct will make a deep clone of the source. Sub-mappings-methods have to be allowed (default option).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>During the generation of automatic sub-mapping methods <a href="#shared-configurations">Shared configurations</a> will not be taken into consideration, yet.
Follow issue <a href="https://github.com/mapstruct/mapstruct/issues/1086">#1086</a> for more information.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Constructor properties of the target object are also considered as target properties.
You can read more about that in <a href="#mapping-with-constructors">Using Constructors</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="controlling-nested-bean-mappings"><a class="anchor" href="#controlling-nested-bean-mappings"></a>5.3. Controlling nested bean mappings</h3>
<div class="paragraph">
<p>As explained above, MapStruct will generate a method based on the name of the source and target property. Unfortunately, in many occasions these names do not match.</p>
</div>
<div class="paragraph">
<p>The ‘.’ notation in an <code>@Mapping</code> source or target type can be used to control how properties should be mapped when names do not match.
There is an elaborate <a href="https://github.com/mapstruct/mapstruct-examples/tree/master/mapstruct-nested-bean-mappings">example</a> in our examples repository to explain how this problem can be overcome.</p>
</div>
<div class="paragraph">
<p>In the simplest scenario there’s a property on a nested level that needs to be corrected.
Take for instance a property <code>fish</code> which has an identical name in <code>FishTankDto</code> and <code>FishTank</code>.
For this property MapStruct automatically generates a mapping: <code>FishDto fishToFishDto(Fish fish)</code>.
MapStruct cannot possibly be aware of the deviating properties <code>kind</code> and <code>type</code>.
Therefore this can be addressed in a mapping rule: <code>@Mapping(target="fish.kind", source="fish.type")</code>.
This tells MapStruct to deviate from looking for a name <code>kind</code> at this level and map it to <code>type</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. Mapper controlling nested beans mappings I</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">FishTankMapper</span> {

    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">fish.kind</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">fish.type</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">fish.name</span><span class="delimiter">&quot;</span></span>, ignore = <span class="predefined-constant">true</span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">ornament</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">interior.ornament</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">material.materialType</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">material</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">quality.report.organisation.name</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">quality.report.organisationName</span><span class="delimiter">&quot;</span></span>)
    FishTankDto map( FishTank source );
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The same constructs can be used to ignore certain properties at a nesting level, as is demonstrated in the second <code>@Mapping</code> rule.</p>
</div>
<div class="paragraph">
<p>MapStruct can even be used to “cherry pick” properties when source and target do not share the same nesting level (the same number of properties).
This can be done in the source – and in the target type. This is demonstrated in the next 2 rules: <code>@Mapping(target="ornament", source="interior.ornament")</code> and <code>@Mapping(target="material.materialType", source="material")</code>.</p>
</div>
<div class="paragraph">
<p>The latter can even be done when mappings first share a common base.
For example: all properties that share the same name of <code>Quality</code> are mapped to <code>QualityDto</code>.
Likewise, all properties of <code>Report</code> are mapped to <code>ReportDto</code>, with one exception: <code>organisation</code> in <code>OrganisationDto</code> is left empty (since there is no organization at the source level).
Only the <code>name</code> is populated with the <code>organisationName</code> from <code>Report</code>.
This is demonstrated in <code>@Mapping(target="quality.report.organisation.name", source="quality.report.organisationName")</code></p>
</div>
<div class="paragraph">
<p>Coming back to the original example: what if <code>kind</code> and <code>type</code> would be beans themselves?
In that case MapStruct would again generate a method continuing to map.
Such is demonstrated in the next example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. Mapper controlling nested beans mappings II</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">FishTankMapperWithDocument</span> {

    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">fish.kind</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">fish.type</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">fish.name</span><span class="delimiter">&quot;</span></span>, expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">java(</span><span class="char">\&quot;</span><span class="content">Jaws</span><span class="char">\&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">plant</span><span class="delimiter">&quot;</span></span>, ignore = <span class="predefined-constant">true</span> )
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">ornament</span><span class="delimiter">&quot;</span></span>, ignore = <span class="predefined-constant">true</span> )
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">material</span><span class="delimiter">&quot;</span></span>, ignore = <span class="predefined-constant">true</span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">quality.document</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">quality.report</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">quality.document.organisation.name</span><span class="delimiter">&quot;</span></span>, constant = <span class="string"><span class="delimiter">&quot;</span><span class="content">NoIdeaInc</span><span class="delimiter">&quot;</span></span> )
    FishTankWithNestedDocumentDto map( FishTank source );

}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note what happens in <code>@Mapping(target="quality.document", source="quality.report")</code>.
<code>DocumentDto</code> does not exist as such on the target side. It is mapped from <code>Report</code>.
MapStruct continues to generate mapping code here. That mapping itself can be guided towards another name.
This even works for constants and expression. Which is shown in the final example: <code>@Mapping(target="quality.document.organisation.name", constant="NoIdeaInc")</code>.</p>
</div>
<div class="paragraph">
<p>MapStruct will perform a null check on each nested property in the source.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Instead of configuring everything via the parent method we encourage users to explicitly write their own nested methods.
This puts the configuration of the nested mapping into one place (method) where it can be reused from several methods in the upper level,
instead of re-configuring the same things on all of those upper methods.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In some cases the <code>ReportingPolicy</code> that is going to be used for the generated nested method would be <code>IGNORE</code>.
This means that it is possible for MapStruct not to report unmapped target properties in nested mappings.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="invoking-custom-mapping-method"><a class="anchor" href="#invoking-custom-mapping-method"></a>5.4. Invoking custom mapping method</h3>
<div class="paragraph">
<p>Sometimes mappings are not straightforward and some fields require custom logic.</p>
</div>
<div class="paragraph">
<p>The example below demonstrates how the properties <code>length</code>, <code>width</code> and <code>height</code> in <code>FishTank</code> can be mapped to the <code>VolumeDto</code> bean, which is a member of <code>FishTankWithVolumeDto</code>. <code>VolumeDto</code> contains the properties <code>volume</code> and <code>description</code>. Custom logic is achieved by defining a method which takes <code>FishTank</code> instance as a parameter and returns a <code>VolumeDto</code>. MapStruct will take the entire parameter <code>source</code> and generate code to call the custom method <code>mapVolume</code> in order to map the <code>FishTank</code> object to the target property <code>volume</code>.</p>
</div>
<div class="paragraph">
<p>The remainder of the fields could be mapped the regular way: using mappings defined defined by means of <code>@Mapping</code> annotations.</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. Manually implemented mapping method</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">FishTank</span> {
    Fish fish;
    <span class="predefined-type">String</span> material;
    Quality quality;
    <span class="type">int</span> length;
    <span class="type">int</span> width;
    <span class="type">int</span> height;
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">FishTankWithVolumeDto</span> {
    FishDto fish;
    MaterialDto material;
    QualityDto quality;
    VolumeDto volume;
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">VolumeDto</span> {
    <span class="type">int</span> volume;
    <span class="predefined-type">String</span> description;
}

<span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">FishTankMapperWithVolume</span> {

    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">fish.kind</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">source.fish.type</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">material.materialType</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">source.material</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">quality.document</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">source.quality.report</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">volume</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">source</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">abstract</span> FishTankWithVolumeDto map(FishTank source);

    VolumeDto mapVolume(FishTank source) {
        <span class="type">int</span> volume = source.length * source.width * source.height;
        <span class="predefined-type">String</span> desc = volume &lt; <span class="integer">100</span> ? <span class="string"><span class="delimiter">&quot;</span><span class="content">Small</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">Large</span><span class="delimiter">&quot;</span></span>;
        <span class="keyword">return</span> <span class="keyword">new</span> VolumeDto(volume, desc);
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note the <code>@Mapping</code> annotation where <code>source</code> field is equal to <code>"source"</code>, indicating the parameter name <code>source</code> itself in the method <code>map(FishTank source)</code> instead of a (target) property in <code>FishTank</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="invoking-other-mappers"><a class="anchor" href="#invoking-other-mappers"></a>5.5. Invoking other mappers</h3>
<div class="paragraph">
<p>In addition to methods defined on the same mapper type MapStruct can also invoke mapping methods defined in other classes, be it mappers generated by MapStruct or hand-written mapping methods. This can be useful to structure your mapping code in several classes (e.g. with one mapper type per application module) or if you want to provide custom mapping logic which can&#8217;t be generated by MapStruct.</p>
</div>
<div class="paragraph">
<p>For instance the <code>Car</code> class might contain an attribute <code>manufacturingDate</code> while the corresponding DTO attribute is of type String. In order to map this attribute, you could implement a mapper class like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. Manually implemented mapper class</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">DateMapper</span> {

    <span class="directive">public</span> <span class="predefined-type">String</span> asString(<span class="predefined-type">Date</span> date) {
        <span class="keyword">return</span> date != <span class="predefined-constant">null</span> ? <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span>( <span class="string"><span class="delimiter">&quot;</span><span class="content">yyyy-MM-dd</span><span class="delimiter">&quot;</span></span> )
            .format( date ) : <span class="predefined-constant">null</span>;
    }

    <span class="directive">public</span> <span class="predefined-type">Date</span> asDate(<span class="predefined-type">String</span> date) {
        <span class="keyword">try</span> {
            <span class="keyword">return</span> date != <span class="predefined-constant">null</span> ? <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span>( <span class="string"><span class="delimiter">&quot;</span><span class="content">yyyy-MM-dd</span><span class="delimiter">&quot;</span></span> )
                .parse( date ) : <span class="predefined-constant">null</span>;
        }
        <span class="keyword">catch</span> ( <span class="exception">ParseException</span> e ) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>( e );
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the <code>@Mapper</code> annotation at the <code>CarMapper</code> interface reference the <code>DateMapper</code> class like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. Referencing another mapper class</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>(uses=DateMapper.class)
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    CarDto carToCarDto(Car car);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When generating code for the implementation of the <code>carToCarDto()</code> method, MapStruct will look for a method which maps a <code>Date</code> object into a String, find it on the <code>DateMapper</code> class and generate an invocation of <code>asString()</code> for mapping the <code>manufacturingDate</code> attribute.</p>
</div>
<div class="paragraph">
<p>Generated mappers retrieve referenced mappers using the component model configured for them. If e.g. CDI was used as component model for <code>CarMapper</code>, <code>DateMapper</code> would have to be a CDI bean as well. When using the default component model, any hand-written mapper classes to be referenced by MapStruct generated mappers must declare a public no-args constructor in order to be instantiable.</p>
</div>
</div>
<div class="sect2">
<h3 id="passing-target-type"><a class="anchor" href="#passing-target-type"></a>5.6. Passing the mapping target type to custom mappers</h3>
<div class="paragraph">
<p>When having a custom mapper hooked into the generated mapper with <code>@Mapper#uses()</code>, an additional parameter of type <code>Class</code> (or a super-type of it) can be defined in the custom mapping method in order to perform general mapping tasks for specific target object types. That attribute must be annotated with <code>@TargetType</code> for MapStruct to generate calls that pass the <code>Class</code> instance representing the corresponding property type of the target bean.</p>
</div>
<div class="paragraph">
<p>For instance, the <code>CarDto</code> could have a property <code>owner</code> of type <code>Reference</code> that contains the primary key of a <code>Person</code> entity. You could now create a generic custom mapper that resolves any <code>Reference</code> objects to their corresponding managed JPA entity instances.</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. Mapping method expecting mapping target type as parameter</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td>
  <td class="code"><pre><span class="annotation">@ApplicationScoped</span> <span class="comment">// CDI component model</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ReferenceMapper</span> {

    <span class="annotation">@PersistenceContext</span>
    <span class="directive">private</span> EntityManager entityManager;

    <span class="directive">public</span> &lt;T <span class="directive">extends</span> BaseEntity&gt; T resolve(<span class="predefined-type">Reference</span> reference, <span class="annotation">@TargetType</span> <span class="predefined-type">Class</span>&lt;T&gt; entityClass) {
        <span class="keyword">return</span> reference != <span class="predefined-constant">null</span> ? entityManager.find( entityClass, reference.getPk() ) : <span class="predefined-constant">null</span>;
    }

    <span class="directive">public</span> <span class="predefined-type">Reference</span> toReference(BaseEntity entity) {
        <span class="keyword">return</span> entity != <span class="predefined-constant">null</span> ? <span class="keyword">new</span> <span class="predefined-type">Reference</span>( entity.getPk() ) : <span class="predefined-constant">null</span>;
    }
}

<span class="annotation">@Mapper</span>(componentModel = <span class="string"><span class="delimiter">&quot;</span><span class="content">cdi</span><span class="delimiter">&quot;</span></span>, uses = ReferenceMapper.class )
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    Car carDtoToCar(CarDto carDto);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>MapStruct will then generate something like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. Generated code</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td>
  <td class="code"><pre><span class="comment">//GENERATED CODE</span>
<span class="annotation">@ApplicationScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CarMapperImpl</span> <span class="directive">implements</span> CarMapper {

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> ReferenceMapper referenceMapper;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Car carDtoToCar(CarDto carDto) {
        <span class="keyword">if</span> ( carDto == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        Car car = <span class="keyword">new</span> Car();

        car.setOwner( referenceMapper.resolve( carDto.getOwner(), <span class="predefined-type">Owner</span>.class ) );
        <span class="comment">// ...</span>

        <span class="keyword">return</span> car;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="passing-context"><a class="anchor" href="#passing-context"></a>5.7. Passing context or state objects to custom methods</h3>
<div class="paragraph">
<p>Additional <em>context</em> or <em>state</em> information can be passed through generated mapping methods to custom methods with <code>@Context</code> parameters. Such parameters are passed to other mapping methods, <code>@ObjectFactory</code> methods (see <a href="#object-factories">Object factories</a>) or <code>@BeforeMapping</code> / <code>@AfterMapping</code> methods (see <a href="#customizing-mappings-with-before-and-after">Mapping customization with before-mapping and after-mapping methods</a>) when applicable and can thus be used in custom code.</p>
</div>
<div class="paragraph">
<p><code>@Context</code> parameters are searched for <code>@ObjectFactory</code> methods, which are called on the provided context parameter value if applicable.</p>
</div>
<div class="paragraph">
<p><code>@Context</code> parameters are also searched for <code>@BeforeMapping</code> / <code>@AfterMapping</code> methods, which are called on the provided context parameter value if applicable.</p>
</div>
<div class="paragraph">
<p><strong>Note:</strong> no <code>null</code> checks are performed before calling before/after mapping methods on context parameters. The caller needs to make sure that <code>null</code> is not passed in that case.</p>
</div>
<div class="paragraph">
<p>For generated code to call a method that is declared with <code>@Context</code> parameters, the declaration of the mapping method being generated needs to contain at least those (or assignable) <code>@Context</code> parameters as well. The generated code will not create new instances of missing <code>@Context</code> parameters nor will it pass a literal <code>null</code> instead.</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. Using <code>@Context</code> parameters for passing data down to hand-written property mapping methods</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="directive">abstract</span> CarDto toCar(Car car, <span class="annotation">@Context</span> <span class="predefined-type">Locale</span> translationLocale);

<span class="directive">protected</span> OwnerManualDto translateOwnerManual(OwnerManual ownerManual, <span class="annotation">@Context</span> <span class="predefined-type">Locale</span> locale) {
    <span class="comment">// manually implemented logic to translate the OwnerManual with the given Locale</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>MapStruct will then generate something like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. Generated code</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="comment">//GENERATED CODE</span>
<span class="directive">public</span> CarDto toCar(Car car, <span class="predefined-type">Locale</span> translationLocale) {
    <span class="keyword">if</span> ( car == <span class="predefined-constant">null</span> ) {
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

    CarDto carDto = <span class="keyword">new</span> CarDto();

    carDto.setOwnerManual( translateOwnerManual( car.getOwnerManual(), translationLocale );
    <span class="comment">// more generated mapping code</span>

    <span class="keyword">return</span> carDto;
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mapping-method-resolution"><a class="anchor" href="#mapping-method-resolution"></a>5.8. Mapping method resolution</h3>
<div class="paragraph">
<p>When mapping a property from one type to another, MapStruct looks for the most specific method which maps the source type into the target type. The method may either be declared on the same mapper interface or on another mapper which is registered via <code>@Mapper#uses()</code>. The same applies for factory methods (see <a href="#object-factories">Object factories</a>).</p>
</div>
<div class="paragraph">
<p>The algorithm for finding a mapping or factory method resembles Java&#8217;s method resolution algorithm as much as possible. In particular, methods with a more specific source type will take precedence (e.g. if there are two methods, one which maps the searched source type, and another one which maps a super-type of the same). In case more than one most-specific method is found, an error will be raised.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When working with JAXB, e.g. when converting a <code>String</code> to a corresponding <code>JAXBElement&lt;String&gt;</code>, MapStruct will take the <code>scope</code> and <code>name</code> attributes of <code>@XmlElementDecl</code> annotations into account when looking for a mapping method. This makes sure that the created <code>JAXBElement</code> instances will have the right QNAME value. You can find a test which maps JAXB objects <a href="https://github.com/mapstruct/mapstruct/blob/1.4.2.Final/integrationtest/src/test/resources/jaxbTest/src/test/java/org/mapstruct/itest/jaxb/JaxbBasedMapperTest.java">here</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="selection-based-on-qualifiers"><a class="anchor" href="#selection-based-on-qualifiers"></a>5.9. Mapping method selection based on qualifiers</h3>
<div class="paragraph">
<p>In many occasions one requires mapping methods with the same method signature (apart from the name) that have different behavior.
MapStruct has a handy mechanism to deal with such situations: <code>@Qualifier</code> (<code>org.mapstruct.Qualifier</code>).
A ‘qualifier’ is a custom annotation that the user can write, ‘stick onto’ a mapping method which is included as used mapper
and can be referred to in a bean property mapping, iterable mapping or map mapping.
Multiple qualifiers can be ‘stuck onto’ a method and mapping.</p>
</div>
<div class="paragraph">
<p>So, let&#8217;s say there is a hand-written method to map titles with a <code>String</code> return type and <code>String</code> argument amongst many other referenced mappers with the same <code>String</code> return type  - <code>String</code> argument signature:</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. Several mapping methods with identical source and target types</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">Titles</span> {

    <span class="directive">public</span> <span class="predefined-type">String</span> translateTitleEG(<span class="predefined-type">String</span> title) {
        <span class="comment">// some mapping logic</span>
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> translateTitleGE(<span class="predefined-type">String</span> title) {
        <span class="comment">// some mapping logic</span>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And a mapper using this handwritten mapper, in which source and target have a property 'title' that should be mapped:</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. Mapper causing an ambiguous mapping method error</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>( uses = Titles.class )
<span class="directive">public</span> <span class="type">interface</span> <span class="class">MovieMapper</span> {

     GermanRelease toGerman( OriginalRelease movies );

}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Without the use of qualifiers, this would result in an ambiguous mapping method error, because 2 qualifying methods are found (<code>translateTitleEG</code>, <code>translateTitleGE</code>) and MapStruct would not have a hint which one to choose.</p>
</div>
<div class="paragraph">
<p>Enter the qualifier approach:</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. Declaring a qualifier type</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">org.mapstruct.Qualifier</span>;

<span class="annotation">@Qualifier</span>
<span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.TYPE)
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.CLASS)
<span class="directive">public</span> <span class="annotation">@interface</span> TitleTranslator {
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And, some qualifiers to indicate which translator to use to map from source language to target language:</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. Declaring qualifier types for mapping methods</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">org.mapstruct.Qualifier</span>;

<span class="annotation">@Qualifier</span>
<span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.METHOD)
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.CLASS)
<span class="directive">public</span> <span class="annotation">@interface</span> EnglishToGerman {
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">org.mapstruct.Qualifier</span>;

<span class="annotation">@Qualifier</span>
<span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.METHOD)
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.CLASS)
<span class="directive">public</span> <span class="annotation">@interface</span> GermanToEnglish {
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Please take note of the target <code>TitleTranslator</code> on type level, <code>EnglishToGerman</code>, <code>GermanToEnglish</code> on method level!</p>
</div>
<div class="paragraph">
<p>Then, using the qualifiers, the mapping could look like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. Mapper using qualifiers</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>( uses = Titles.class )
<span class="directive">public</span> <span class="type">interface</span> <span class="class">MovieMapper</span> {

     <span class="annotation">@Mapping</span>( target = <span class="string"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>, qualifiedBy = { TitleTranslator.class, EnglishToGerman.class } )
     GermanRelease toGerman( OriginalRelease movies );

}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 48. Custom mapper qualifying the methods it provides</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="annotation">@TitleTranslator</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Titles</span> {

    <span class="annotation">@EnglishToGerman</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> translateTitleEG(<span class="predefined-type">String</span> title) {
        <span class="comment">// some mapping logic</span>
    }

    <span class="annotation">@GermanToEnglish</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> translateTitleGE(<span class="predefined-type">String</span> title) {
        <span class="comment">// some mapping logic</span>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Please make sure the used retention policy equals retention policy <code>CLASS</code> (<code>@Retention(RetentionPolicy.CLASS)</code>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A class / method annotated with a qualifier will not qualify anymore for mappings that do not have the <code>qualifiedBy</code> element.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The same mechanism is also present on bean mappings: <code>@BeanMapping#qualifiedBy</code>: it selects the factory method marked with the indicated qualifier.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In many occasions, declaring a new annotation to aid the selection process can be too much for what you try to achieve. For those situations, MapStruct has the <code>@Named</code> annotation. This annotation is a pre-defined qualifier (annotated with <code>@Qualifier</code> itself) and can be used to name a Mapper or, more directly a mapping method by means of its value. The same example above would look like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 49. Custom mapper, annotating the methods to qualify by means of <code>@Named</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">TitleTranslator</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Titles</span> {

    <span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">EnglishToGerman</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="predefined-type">String</span> translateTitleEG(<span class="predefined-type">String</span> title) {
        <span class="comment">// some mapping logic</span>
    }

    <span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">GermanToEnglish</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="predefined-type">String</span> translateTitleGE(<span class="predefined-type">String</span> title) {
        <span class="comment">// some mapping logic</span>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 50. Mapper using named</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>( uses = Titles.class )
<span class="directive">public</span> <span class="type">interface</span> <span class="class">MovieMapper</span> {

     <span class="annotation">@Mapping</span>( target = <span class="string"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>, qualifiedByName = { <span class="string"><span class="delimiter">&quot;</span><span class="content">TitleTranslator</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">EnglishToGerman</span><span class="delimiter">&quot;</span></span> } )
     GermanRelease toGerman( OriginalRelease movies );

}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Although the used mechanism is the same, the user has to be a bit more careful. Refactoring the name of a defined qualifier in an IDE will neatly refactor all other occurrences as well. This is obviously not the case for changing a name.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mapping-collections"><a class="anchor" href="#mapping-collections"></a>6. Mapping collections</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The mapping of collection types (<code>List</code>, <code>Set</code> etc.) is done in the same way as mapping bean types, i.e. by defining mapping methods with the required source and target types in a mapper interface. MapStruct supports a wide range of iterable types from the <a href="http://docs.oracle.com/javase/tutorial/collections/intro/index.html">Java Collection Framework</a>.</p>
</div>
<div class="paragraph">
<p>The generated code will contain a loop which iterates over the source collection, converts each element and puts it into the target collection. If a mapping method for the collection element types is found in the given mapper or the mapper it uses, this method is invoked to perform the element conversion. Alternatively, if an implicit conversion for the source and target element types exists, this conversion routine will be invoked. The following shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 51. Mapper with collection mapping methods</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; integerSetToStringSet(<span class="predefined-type">Set</span>&lt;<span class="predefined-type">Integer</span>&gt; integers);

    <span class="predefined-type">List</span>&lt;CarDto&gt; carsToCarDtos(<span class="predefined-type">List</span>&lt;Car&gt; cars);

    CarDto carToCarDto(Car car);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The generated implementation of the <code>integerSetToStringSet</code> performs the conversion from <code>Integer</code> to <code>String</code> for each element, while the generated <code>carsToCarDtos()</code> method invokes the <code>carToCarDto()</code> method for each contained element as shown in the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 52. Generated collection mapping methods</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td>
  <td class="code"><pre><span class="comment">//GENERATED CODE</span>
<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; integerSetToStringSet(<span class="predefined-type">Set</span>&lt;<span class="predefined-type">Integer</span>&gt; integers) {
    <span class="keyword">if</span> ( integers == <span class="predefined-constant">null</span> ) {
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

    <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; set = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;<span class="predefined-type">String</span>&gt;();

    <span class="keyword">for</span> ( <span class="predefined-type">Integer</span> integer : integers ) {
        set.add( <span class="predefined-type">String</span>.valueOf( integer ) );
    }

    <span class="keyword">return</span> set;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="predefined-type">List</span>&lt;CarDto&gt; carsToCarDtos(<span class="predefined-type">List</span>&lt;Car&gt; cars) {
    <span class="keyword">if</span> ( cars == <span class="predefined-constant">null</span> ) {
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

    <span class="predefined-type">List</span>&lt;CarDto&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;CarDto&gt;();

    <span class="keyword">for</span> ( Car car : cars ) {
        list.add( carToCarDto( car ) );
    }

    <span class="keyword">return</span> list;
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that MapStruct will look for a collection mapping method with matching parameter and return type, when mapping a collection-typed attribute of a bean, e.g. from <code>Car#passengers</code> (of type <code>List&lt;Person&gt;</code>) to <code>CarDto#passengers</code> (of type <code>List&lt;PersonDto&gt;</code>).</p>
</div>
<div class="exampleblock">
<div class="title">Example 53. Usage of collection mapping method to map a bean property</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="comment">//GENERATED CODE</span>
carDto.setPassengers( personsToPersonDtos( car.getPassengers() ) );
...</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Some frameworks and libraries only expose JavaBeans getters but no setters for collection-typed properties. Types generated from an XML schema using JAXB adhere to this pattern by default. In this case the generated code for mapping such a property invokes its getter and adds all the mapped elements:</p>
</div>
<div class="exampleblock">
<div class="title">Example 54. Usage of an adding method for collection mapping</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="comment">//GENERATED CODE</span>
carDto.getPassengers().addAll( personsToPersonDtos( car.getPassengers() ) );
...</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is not allowed to declare mapping methods with an iterable source and a non-iterable target or the other way around. An error will be raised when detecting this situation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="mapping-maps"><a class="anchor" href="#mapping-maps"></a>6.1. Mapping maps</h3>
<div class="paragraph">
<p>Also map-based mapping methods are supported. The following shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 55. Map mapping method</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">interface</span> <span class="class">SourceTargetMapper</span> {

    <span class="annotation">@MapMapping</span>(valueDateFormat = <span class="string"><span class="delimiter">&quot;</span><span class="content">dd.MM.yyyy</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; longDateMapToStringStringMap(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">Long</span>, <span class="predefined-type">Date</span>&gt; source);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Similar to iterable mappings, the generated code will iterate through the source map, convert each value and key (either by means of an implicit conversion or by invoking another mapping method) and put them into the target map:</p>
</div>
<div class="exampleblock">
<div class="title">Example 56. Generated implementation of map mapping method</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td>
  <td class="code"><pre><span class="comment">//GENERATED CODE</span>
<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Long</span>, <span class="predefined-type">Date</span>&gt; stringStringMapToLongDateMap(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; source) {
    <span class="keyword">if</span> ( source == <span class="predefined-constant">null</span> ) {
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

    <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Long</span>, <span class="predefined-type">Date</span>&gt; map = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;<span class="predefined-type">Long</span>, <span class="predefined-type">Date</span>&gt;();

    <span class="keyword">for</span> ( <span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; entry : source.entrySet() ) {

        <span class="predefined-type">Long</span> key = <span class="predefined-type">Long</span>.parseLong( entry.getKey() );
        <span class="predefined-type">Date</span> value;
        <span class="keyword">try</span> {
            value = <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span>( <span class="string"><span class="delimiter">&quot;</span><span class="content">dd.MM.yyyy</span><span class="delimiter">&quot;</span></span> ).parse( entry.getValue() );
        }
        <span class="keyword">catch</span>( <span class="exception">ParseException</span> e ) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>( e );
        }

        map.put( key, value );
    }

    <span class="keyword">return</span> map;
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="collection-mapping-strategies"><a class="anchor" href="#collection-mapping-strategies"></a>6.2. Collection mapping strategies</h3>
<div class="paragraph">
<p>MapStruct has a <code>CollectionMappingStrategy</code>, with the possible values: <code>ACCESSOR_ONLY</code>, <code>SETTER_PREFERRED</code>, <code>ADDER_PREFERRED</code> and <code>TARGET_IMMUTABLE</code>.</p>
</div>
<div class="paragraph">
<p>In the table below, the dash <code>-</code> indicates a property name. Next, the trailing <code>s</code> indicates the plural form. The table explains the options and how they are applied to the presence/absence of a <code>set-s</code>, <code>add-</code> and / or <code>get-s</code> method on the target object:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Collection mapping strategy options</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Option</th>
<th class="tableblock halign-left valign-top">Only target set-s Available</th>
<th class="tableblock halign-left valign-top">Only target add- Available</th>
<th class="tableblock halign-left valign-top">Both set-s / add- Available</th>
<th class="tableblock halign-left valign-top">No set-s / add- Available</th>
<th class="tableblock halign-left valign-top">Existing Target(<code>@TargetType</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ACCESSOR_ONLY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get-s</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SETTER_PREFERRED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get-s</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ADDER_PREFERRED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get-s</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TARGET_IMMUTABLE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">exception</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set-s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">exception</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set-s</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Some background: An <code>adder</code> method is typically used in case of <a href="http://www.eclipse.org/webtools/dali/">generated (JPA) entities</a>, to add a single element (entity) to an underlying collection. Invoking the adder establishes a parent-child relation between parent - the bean (entity) on which the adder is invoked - and its child(ren), the elements (entities) in the collection. To find the appropriate <code>adder</code>, MapStruct will try to make a match between the generic parameter type of the underlying collection and the single argument of a candidate <code>adder</code>. When there are more candidates, the plural <code>setter</code> / <code>getter</code> name is converted to singular and will be used in addition to make a match.</p>
</div>
<div class="paragraph">
<p>The option <code>DEFAULT</code> should not be used explicitly. It is used to distinguish between an explicit user desire to override the default in a <code>@MapperConfig</code> from the implicit Mapstruct choice in a <code>@Mapper</code>. The option <code>DEFAULT</code> is synonymous to <code>ACCESSOR_ONLY</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When working with an <code>adder</code> method and JPA entities, Mapstruct assumes that the target collections are initialized with a collection implementation (e.g. an <code>ArrayList</code>). You can use factories to create a new target entity with intialized collections instead of Mapstruct creating the target entity by its constructor.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="implementation-types-for-collection-mappings"><a class="anchor" href="#implementation-types-for-collection-mappings"></a>6.3. Implementation types used for collection mappings</h3>
<div class="paragraph">
<p>When an iterable or map mapping method declares an interface type as return type, one of its implementation types will be instantiated in the generated code. The following table shows the supported interface types and their corresponding implementation types as instantiated in the generated code:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Collection mapping implementation types</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Interface type</th>
<th class="tableblock halign-left valign-top">Implementation type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArrayList</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArrayList</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArrayList</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Set</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HashSet</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SortedSet</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TreeSet</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NavigableSet</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TreeSet</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Map</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HashMap</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SortedMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TreeMap</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NavigableMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TreeMap</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConcurrentMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConcurrentHashMap</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConcurrentNavigableMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConcurrentSkipListMap</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mapping-streams"><a class="anchor" href="#mapping-streams"></a>7. Mapping Streams</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The mapping of <code>java.util.Stream</code> is done in a similar way as the mapping of collection types, i.e. by defining mapping
methods with the required source and target types in a mapper interface.</p>
</div>
<div class="paragraph">
<p>The generated code will contain the creation of a <code>Stream</code> from the provided <code>Iterable</code>/array or will collect the
provided <code>Stream</code> into an <code>Iterable</code>/array. If a mapping method or an implicit conversion for the source and target
element types exists, then this conversion will be done in <code>Stream#map()</code>. The following shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 57. Mapper with stream mapping methods</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; integerStreamToStringSet(Stream&lt;<span class="predefined-type">Integer</span>&gt; integers);

    <span class="predefined-type">List</span>&lt;CarDto&gt; carsToCarDtos(Stream&lt;Car&gt; cars);

    CarDto carToCarDto(Car car);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The generated implementation of the <code>integerStreamToStringSet()</code> performs the conversion from <code>Integer</code> to <code>String</code> for
each element, while the generated <code>carsToCarDtos()</code> method invokes the <code>carToCarDto()</code> method for each contained
element as shown in the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 58. Generated stream mapping methods</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td>
  <td class="code"><pre><span class="comment">//GENERATED CODE</span>
<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; integerStreamToStringSet(Stream&lt;<span class="predefined-type">Integer</span>&gt; integers) {
    <span class="keyword">if</span> ( integers == <span class="predefined-constant">null</span> ) {
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

    <span class="keyword">return</span> integers.map( integer -&gt; <span class="predefined-type">String</span>.valueOf( integer ) )
        .collect( Collectors.toCollection( <span class="predefined-type">HashSet</span>&lt;<span class="predefined-type">String</span>&gt;::<span class="keyword">new</span> ) );
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="predefined-type">List</span>&lt;CarDto&gt; carsToCarDtos(Stream&lt;Car&gt; cars) {
    <span class="keyword">if</span> ( cars == <span class="predefined-constant">null</span> ) {
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

    <span class="keyword">return</span> cars.map( car -&gt; carToCarDto( car ) )
        .collect( Collectors.toCollection( <span class="predefined-type">ArrayList</span>&lt;CarDto&gt;::<span class="keyword">new</span> ) );
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If a mapping from a <code>Stream</code> to an <code>Iterable</code> or an array is performed, then the passed <code>Stream</code> will be consumed
and it will no longer be possible to consume it.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The same implementation types as in <a href="#implementation-types-for-collection-mappings">Implementation types used for collection mappings</a> are used for the creation of the
collection when doing <code>Stream</code> to <code>Iterable</code> mapping.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mapping-enum-types"><a class="anchor" href="#mapping-enum-types"></a>8. Mapping Values</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_mapping_enum_to_enum_types"><a class="anchor" href="#_mapping_enum_to_enum_types"></a>8.1. Mapping enum to enum types</h3>
<div class="paragraph">
<p>MapStruct supports the generation of methods which map one Java enum type into another.</p>
</div>
<div class="paragraph">
<p>By default, each constant from the source enum is mapped to a constant with the same name in the target enum type. If required, a constant from the source enum may be mapped to a constant with another name with help of the <code>@ValueMapping</code> annotation. Several constants from the source enum can be mapped to the same constant in the target type.</p>
</div>
<div class="paragraph">
<p>The following shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 59. Enum mapping method</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">OrderMapper</span> {

    OrderMapper INSTANCE = Mappers.getMapper( OrderMapper.class );

    <span class="annotation">@ValueMappings</span>({
        <span class="annotation">@ValueMapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">EXTRA</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">SPECIAL</span><span class="delimiter">&quot;</span></span>),
        <span class="annotation">@ValueMapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">STANDARD</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">DEFAULT</span><span class="delimiter">&quot;</span></span>),
        <span class="annotation">@ValueMapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">NORMAL</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">DEFAULT</span><span class="delimiter">&quot;</span></span>)
    })
    ExternalOrderType orderTypeToExternalOrderType(OrderType orderType);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 60. Enum mapping method result</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td>
  <td class="code"><pre><span class="comment">// GENERATED CODE</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">OrderMapperImpl</span> <span class="directive">implements</span> OrderMapper {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> ExternalOrderType orderTypeToExternalOrderType(OrderType orderType) {
        <span class="keyword">if</span> ( orderType == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        ExternalOrderType externalOrderType_;

        <span class="keyword">switch</span> ( orderType ) {
            <span class="keyword">case</span> EXTRA: externalOrderType_ = ExternalOrderType.SPECIAL;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> STANDARD: externalOrderType_ = ExternalOrderType.DEFAULT;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> NORMAL: externalOrderType_ = ExternalOrderType.DEFAULT;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> RETAIL: externalOrderType_ = ExternalOrderType.RETAIL;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> B2B: externalOrderType_ = ExternalOrderType.B2B;
            <span class="keyword">break</span>;
            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>( <span class="string"><span class="delimiter">&quot;</span><span class="content">Unexpected enum constant: </span><span class="delimiter">&quot;</span></span> + orderType );
        }

        <span class="keyword">return</span> externalOrderType_;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default an error will be raised by MapStruct in case a constant of the source enum type does not have a corresponding constant with the same name in the target type and also is not mapped to another constant via <code>@ValueMapping</code>. This ensures that all constants are mapped in a safe and predictable manner. The generated
mapping method will throw an IllegalStateException if for some reason an unrecognized source value occurs.</p>
</div>
<div class="paragraph">
<p>MapStruct also has a mechanism for mapping any remaining (unspecified) mappings to a default. This can be used only once in a set of value mappings and only applies to the source. It comes in two flavors: <code>&lt;ANY_REMAINING&gt;</code> and <code>&lt;ANY_UNMAPPED&gt;</code>. They cannot be used at the same time.</p>
</div>
<div class="paragraph">
<p>In case of source <code>&lt;ANY_REMAINING&gt;</code> MapStruct will continue to map a source enum constant to a target enum constant with the same name. The remainder of the source enum constants will be mapped to the target specified in the <code>@ValueMapping</code> with <code>&lt;ANY_REMAINING&gt;</code> source.</p>
</div>
<div class="paragraph">
<p>MapStruct will <strong>not</strong> attempt such name based mapping for <code>&lt;ANY_UNMAPPED&gt;</code> and directly apply the target specified in the <code>@ValueMapping</code> with <code>&lt;ANY_UNMAPPED&gt;</code> source to the remainder.</p>
</div>
<div class="paragraph">
<p>MapStruct is able to handle <code>null</code> sources and <code>null</code> targets by means of the <code>&lt;NULL&gt;</code> keyword.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Constants for <code>&lt;ANY_REMAINING&gt;</code>, <code>&lt;ANY_UNMAPPED&gt;</code> and <code>&lt;NULL&gt;</code> are available in the <code>MappingConstants</code> class.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally <code>@InheritInverseConfiguration</code> and <code>@InheritConfiguration</code> can be used in combination with <code>@ValueMappings</code>. <code>&lt;ANY_REMAINING&gt;</code> and <code>&lt;ANY_UNMAPPED&gt;</code> will be ignored in that case.</p>
</div>
<div class="exampleblock">
<div class="title">Example 61. Enum mapping method, &lt;NULL&gt; and &lt;ANY_REMAINING&gt;</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">SpecialOrderMapper</span> {

    SpecialOrderMapper INSTANCE = Mappers.getMapper( SpecialOrderMapper.class );

    <span class="annotation">@ValueMappings</span>({
        <span class="annotation">@ValueMapping</span>( source = MappingConstants.NULL, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">DEFAULT</span><span class="delimiter">&quot;</span></span> ),
        <span class="annotation">@ValueMapping</span>( source = <span class="string"><span class="delimiter">&quot;</span><span class="content">STANDARD</span><span class="delimiter">&quot;</span></span>, target = MappingConstants.NULL ),
        <span class="annotation">@ValueMapping</span>( source = MappingConstants.ANY_REMAINING, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">SPECIAL</span><span class="delimiter">&quot;</span></span> )
    })
    ExternalOrderType orderTypeToExternalOrderType(OrderType orderType);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 62. Enum mapping method result, &lt;NULL&gt; and &lt;ANY_REMAINING&gt;</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="comment">// GENERATED CODE</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SpecialOrderMapperImpl</span> <span class="directive">implements</span> SpecialOrderMapper {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> ExternalOrderType orderTypeToExternalOrderType(OrderType orderType) {
        <span class="keyword">if</span> ( orderType == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> ExternalOrderType.DEFAULT;
        }

        ExternalOrderType externalOrderType_;

        <span class="keyword">switch</span> ( orderType ) {
            <span class="keyword">case</span> STANDARD: externalOrderType_ = <span class="predefined-constant">null</span>;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> RETAIL: externalOrderType_ = ExternalOrderType.RETAIL;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> B2B: externalOrderType_ = ExternalOrderType.B2B;
            <span class="keyword">break</span>;
            <span class="keyword">default</span>: externalOrderType_ = ExternalOrderType.SPECIAL;
        }

        <span class="keyword">return</span> externalOrderType_;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><strong>Note:</strong> MapStruct would have refrained from mapping the <code>RETAIL</code> and <code>B2B</code> when <code>&lt;ANY_UNMAPPED&gt;</code> was used instead of <code>&lt;ANY_REMAINING&gt;</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The mapping of enum to enum via the <code>@Mapping</code> annotation is <strong>DEPRECATED</strong>. It will be removed from future versions of MapStruct. Please adapt existing enum mapping methods to make use of <code>@ValueMapping</code> instead.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_mapping_enum_to_string_or_string_to_enum"><a class="anchor" href="#_mapping_enum_to_string_or_string_to_enum"></a>8.2. Mapping enum-to-String or String-to-enum</h3>
<div class="paragraph">
<p>MapStruct supports enum to a String mapping along the same lines as is described in <a href="#_mapping_enum_to_enum_types">enum-to-enum types</a>. There are similarities and differences:</p>
</div>
<div class="paragraph">
<p><strong>enum to <code>String</code></strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Similarity: All not explicit defined mappings will result in each source enum constant value being mapped a <code>String</code> value with the same constant value.</p>
</li>
<li>
<p>Similarity: <code>&lt;ANY_UNMAPPED</code>&gt; stops after handling defined mapping and proceeds to the switch/default clause value.</p>
</li>
<li>
<p>Difference: <code>&lt;ANY_REMAINING&gt;</code> will result in an error. It acts on the premise that there is name similarity between enum constants in source and target which does not make sense for a String type.</p>
</li>
<li>
<p>Difference: Given 1. and 3. there will never be unmapped values.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong><code>String</code> to enum</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Similarity: All not explicit defined mappings will result in the target enum constant mapped from the <code>String</code> value when that matches the target enum constant name.</p>
</li>
<li>
<p>Similarity: <code>&lt;ANY_UNMAPPED</code>&gt; stops after handling defined mapping and proceeds to the switch/default clause value.</p>
</li>
<li>
<p>Similarity: <code>&lt;ANY_REMAINING&gt;</code> will create a mapping for each target enum constant and proceed to the switch/default clause value.</p>
</li>
<li>
<p>Difference: A switch/default value needs to be provided to have a determined outcome (enum has a limited set of values, <code>String</code> has unlimited options). Failing to specify <code>&lt;ANY_REMAINING&gt;</code> or <code>&lt;ANY_UNMAPPED</code>&gt; will result in a warning.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_custom_name_transformation"><a class="anchor" href="#_custom_name_transformation"></a>8.3. Custom name transformation</h3>
<div class="paragraph">
<p>When no <code>@ValueMapping</code>(s) are defined then each constant from the source enum is mapped to a constant with the same name in the target enum type.
However, there are cases where the source enum needs to be transformed before doing the mapping.
E.g. a suffix needs to be applied to map from the source into the target enum.</p>
</div>
<div class="exampleblock">
<div class="title">Example 63. Enum types</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">enum</span> CheeseType {

    BRIE,
    ROQUEFORT
}

<span class="directive">public</span> <span class="type">enum</span> CheeseTypeSuffixed {

    BRIE_TYPE,
    ROQUEFORT_TYPE
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 64. Enum mapping method with custom name transformation strategy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CheeseMapper</span> {

    CheeseMapper INSTANCE = Mappers.getMapper( CheeseMapper.class );

    <span class="annotation">@EnumMapping</span>(nameTransformationStrategy = <span class="string"><span class="delimiter">&quot;</span><span class="content">suffix</span><span class="delimiter">&quot;</span></span>, configuration = <span class="string"><span class="delimiter">&quot;</span><span class="content">_TYPE</span><span class="delimiter">&quot;</span></span>)
    CheeseTypeSuffixed map(CheeseType cheese);

    <span class="annotation">@InheritInverseConfiguration</span>
    CheeseType map(CheeseTypeSuffix cheese);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 65. Enum mapping method with custom name transformation strategy result</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td>
  <td class="code"><pre><span class="comment">// GENERATED CODE</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CheeseSuffixMapperImpl</span> <span class="directive">implements</span> CheeseSuffixMapper {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> CheeseTypeSuffixed map(CheeseType cheese) {
        <span class="keyword">if</span> ( cheese == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        CheeseTypeSuffixed cheeseTypeSuffixed;

        <span class="keyword">switch</span> ( cheese ) {
            <span class="keyword">case</span> BRIE: cheeseTypeSuffixed = CheeseTypeSuffixed.BRIE_TYPE;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> ROQUEFORT: cheeseTypeSuffixed = CheeseTypeSuffixed.ROQUEFORT_TYPE;
            <span class="keyword">break</span>;
            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>( <span class="string"><span class="delimiter">&quot;</span><span class="content">Unexpected enum constant: </span><span class="delimiter">&quot;</span></span> + cheese );
        }

        <span class="keyword">return</span> cheeseTypeSuffixed;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> CheeseType map(CheeseTypeSuffixed cheese) {
        <span class="keyword">if</span> ( cheese == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        CheeseType cheeseType;

        <span class="keyword">switch</span> ( cheese ) {
            <span class="keyword">case</span> BRIE_TYPE: cheeseType = CheeseType.BRIE;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> ROQUEFORT_TYPE: cheeseType = CheeseType.ROQUEFORT;
            <span class="keyword">break</span>;
            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>( <span class="string"><span class="delimiter">&quot;</span><span class="content">Unexpected enum constant: </span><span class="delimiter">&quot;</span></span> + cheese );
        }

        <span class="keyword">return</span> cheeseType;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>MapStruct provides the following out of the box enum name transformation strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>suffix</em> - Applies a suffix on the source enum</p>
</li>
<li>
<p><em>stripSuffix</em> - Strips a suffix from the source enum</p>
</li>
<li>
<p><em>prefix</em> - Applies a prefix on the source enum</p>
</li>
<li>
<p><em>stripPrefix</em> - Strips a prefix from the source enum</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is also possible to register custom strategies.
For more information on how to do that have a look at <a href="#custom-enum-transformation-strategy">Custom Enum Transformation Strategy</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="object-factories"><a class="anchor" href="#object-factories"></a>9. Object factories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, the generated code for mapping one bean type into another or updating a bean will call the default constructor to instantiate the target type.</p>
</div>
<div class="paragraph">
<p>Alternatively you can plug in custom object factories which will be invoked to obtain instances of the target type. One use case for this is JAXB which creates <code>ObjectFactory</code> classes for obtaining new instances of schema types.</p>
</div>
<div class="paragraph">
<p>To make use of custom factories register them via <code>@Mapper#uses()</code> as described in <a href="#invoking-other-mappers">Invoking other mappers</a>, or implement them directly in your mapper. When creating the target object of a bean mapping, MapStruct will look for a parameterless method, a method annotated with <code>@ObjectFactory</code>, or a method with only one <code>@TargetType</code> parameter that returns the required target type and invoke this method instead of calling the default constructor:</p>
</div>
<div class="exampleblock">
<div class="title">Example 66. Custom object factories</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">DtoFactory</span> {

     <span class="directive">public</span> CarDto createCarDto() {
         <span class="keyword">return</span> <span class="comment">// ... custom factory logic</span>
     }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">EntityFactory</span> {

     <span class="directive">public</span> &lt;T <span class="directive">extends</span> BaseEntity&gt; T createEntity(<span class="annotation">@TargetType</span> <span class="predefined-type">Class</span>&lt;T&gt; entityClass) {
         <span class="keyword">return</span> <span class="comment">// ... custom factory logic</span>
     }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>(uses= { DtoFactory.class, EntityFactory.class } )
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    CarMapper INSTANCE = Mappers.getMapper( CarMapper.class );

    CarDto carToCarDto(Car car);

    Car carDtoToCar(CarDto carDto);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td>
  <td class="code"><pre><span class="comment">//GENERATED CODE</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CarMapperImpl</span> <span class="directive">implements</span> CarMapper {

    <span class="directive">private</span> <span class="directive">final</span> DtoFactory dtoFactory = <span class="keyword">new</span> DtoFactory();

    <span class="directive">private</span> <span class="directive">final</span> EntityFactory entityFactory = <span class="keyword">new</span> EntityFactory();

    <span class="annotation">@Override</span>
    <span class="directive">public</span> CarDto carToCarDto(Car car) {
        <span class="keyword">if</span> ( car == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        CarDto carDto = dtoFactory.createCarDto();

        <span class="comment">//map properties...</span>

        <span class="keyword">return</span> carDto;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Car carDtoToCar(CarDto carDto) {
        <span class="keyword">if</span> ( carDto == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        Car car = entityFactory.createEntity( Car.class );

        <span class="comment">//map properties...</span>

        <span class="keyword">return</span> car;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 67. Custom object factories with update methods</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>(uses = { DtoFactory.class, EntityFactory.class, CarMapper.class } )
<span class="directive">public</span> <span class="type">interface</span> <span class="class">OwnerMapper</span> {

    OwnerMapper INSTANCE = Mappers.getMapper( OwnerMapper.class );

    <span class="type">void</span> updateOwnerDto(<span class="predefined-type">Owner</span> owner, <span class="annotation">@MappingTarget</span> OwnerDto ownerDto);

    <span class="type">void</span> updateOwner(OwnerDto ownerDto, <span class="annotation">@MappingTarget</span> <span class="predefined-type">Owner</span> owner);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td>
  <td class="code"><pre><span class="comment">//GENERATED CODE</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">OwnerMapperImpl</span> <span class="directive">implements</span> OwnerMapper {

    <span class="directive">private</span> <span class="directive">final</span> DtoFactory dtoFactory = <span class="keyword">new</span> DtoFactory();

    <span class="directive">private</span> <span class="directive">final</span> EntityFactory entityFactory = <span class="keyword">new</span> EntityFactory();

    <span class="directive">private</span> <span class="directive">final</span> OwnerMapper ownerMapper = Mappers.getMapper( OwnerMapper.class );

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> updateOwnerDto(<span class="predefined-type">Owner</span> owner, <span class="annotation">@MappingTarget</span> OwnerDto ownerDto) {
        <span class="keyword">if</span> ( owner == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span>;
        }

        <span class="keyword">if</span> ( owner.getCar() != <span class="predefined-constant">null</span> ) {
            <span class="keyword">if</span> ( ownerDto.getCar() == <span class="predefined-constant">null</span> ) {
                ownerDto.setCar( dtoFactory.createCarDto() );
            }
            <span class="comment">// update car within ownerDto</span>
        }
        <span class="keyword">else</span> {
            ownerDto.setCar( <span class="predefined-constant">null</span> );
        }

       <span class="comment">// updating other properties</span>
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> updateOwner(OwnerDto ownerDto, <span class="annotation">@MappingTarget</span> <span class="predefined-type">Owner</span> owner) {
        <span class="keyword">if</span> ( ownerDto == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span>;
        }

        <span class="keyword">if</span> ( ownerDto.getCar() != <span class="predefined-constant">null</span> ) {
            <span class="keyword">if</span> ( owner.getCar() == <span class="predefined-constant">null</span> ) {
                owner.setCar( entityFactory.createEntity( Car.class ) );
            }
            <span class="comment">// update car within owner</span>
        }
        <span class="keyword">else</span> {
            owner.setCar( <span class="predefined-constant">null</span> );
        }

       <span class="comment">// updating other properties</span>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition, annotating a factory method with <code>@ObjectFactory</code> lets you gain access to the mapping sources.
Source objects can be added as parameters in the same way as for mapping method. The <code>@ObjectFactory</code>
annotation is necessary to let MapStruct know that the given method is only a factory method.</p>
</div>
<div class="exampleblock">
<div class="title">Example 68. Custom object factories with <code>@ObjectFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">DtoFactory</span> {

     <span class="annotation">@ObjectFactory</span>
     <span class="directive">public</span> CarDto createCarDto(Car car) {
         <span class="keyword">return</span> <span class="comment">// ... custom factory logic</span>
     }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_mapping_options"><a class="anchor" href="#_advanced_mapping_options"></a>10. Advanced mapping options</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes several advanced options which allow to fine-tune the behavior of the generated mapping code as needed.</p>
</div>
<div class="sect2">
<h3 id="default-values-and-constants"><a class="anchor" href="#default-values-and-constants"></a>10.1. Default values and constants</h3>
<div class="paragraph">
<p>Default values can be specified to set a predefined value to a target property if the corresponding source property is <code>null</code>. Constants can be specified to set such a predefined value in any case. Default values and constants are specified as String values. When the target type is a primitive or a boxed type, the String value is taken literal. Bit / octal / decimal / hex patterns are allowed in such a case as long as they are a valid literal.
In all other cases, constant or default values are subject to type conversion either via built-in conversions or the invocation of other mapping methods in order to match the type required by the target property.</p>
</div>
<div class="paragraph">
<p>A mapping with a constant must not include a reference to a source property. The following example shows some mappings using default values and constants:</p>
</div>
<div class="exampleblock">
<div class="title">Example 69. Mapping method with default values and constants</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>(uses = StringListMapper.class)
<span class="directive">public</span> <span class="type">interface</span> <span class="class">SourceTargetMapper</span> {

    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );

    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">stringProperty</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">stringProp</span><span class="delimiter">&quot;</span></span>, defaultValue = <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">longProperty</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">longProp</span><span class="delimiter">&quot;</span></span>, defaultValue = <span class="string"><span class="delimiter">&quot;</span><span class="content">-1</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">stringConstant</span><span class="delimiter">&quot;</span></span>, constant = <span class="string"><span class="delimiter">&quot;</span><span class="content">Constant Value</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">integerConstant</span><span class="delimiter">&quot;</span></span>, constant = <span class="string"><span class="delimiter">&quot;</span><span class="content">14</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">longWrapperConstant</span><span class="delimiter">&quot;</span></span>, constant = <span class="string"><span class="delimiter">&quot;</span><span class="content">3001</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">dateConstant</span><span class="delimiter">&quot;</span></span>, dateFormat = <span class="string"><span class="delimiter">&quot;</span><span class="content">dd-MM-yyyy</span><span class="delimiter">&quot;</span></span>, constant = <span class="string"><span class="delimiter">&quot;</span><span class="content">09-01-2014</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">stringListConstants</span><span class="delimiter">&quot;</span></span>, constant = <span class="string"><span class="delimiter">&quot;</span><span class="content">jack-jill-tom</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">Target</span> sourceToTarget(<span class="predefined-type">Source</span> s);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If <code>s.getStringProp() == null</code>, then the target property <code>stringProperty</code> will be set to <code>"undefined"</code> instead of applying the value from <code>s.getStringProp()</code>. If <code>s.getLongProperty() == null</code>, then the target property <code>longProperty</code> will be set to <code>-1</code>.
The String <code>"Constant Value"</code> is set as is to the target property <code>stringConstant</code>. The value <code>"3001"</code> is type-converted to the <code>Long</code> (wrapper) class of target property <code>longWrapperConstant</code>. Date properties also require a date format. The constant <code>"jack-jill-tom"</code> demonstrates how the hand-written class <code>StringListMapper</code> is invoked to map the dash-separated list into a <code>List&lt;String&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="expressions"><a class="anchor" href="#expressions"></a>10.2. Expressions</h3>
<div class="paragraph">
<p>By means of Expressions it will be possible to include constructs from a number of languages.</p>
</div>
<div class="paragraph">
<p>Currently only Java is supported as a language. This feature is e.g. useful to invoke constructors. The entire source object is available for usage in the expression. Care should be taken to insert only valid Java code: MapStruct will not validate the expression at generation-time, but errors will show up in the generated classes during compilation.</p>
</div>
<div class="paragraph">
<p>The example below demonstrates how two source properties can be mapped to one target:</p>
</div>
<div class="exampleblock">
<div class="title">Example 70. Mapping method using an expression</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">SourceTargetMapper</span> {

    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );

    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">timeAndFormat</span><span class="delimiter">&quot;</span></span>,
         expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">java( new org.sample.TimeAndFormat( s.getTime(), s.getFormat() ) )</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">Target</span> sourceToTarget(<span class="predefined-type">Source</span> s);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The example demonstrates how the source properties <code>time</code> and <code>format</code> are composed into one target property <code>TimeAndFormat</code>. Please note that the fully qualified package name is specified because MapStruct does not take care of the import of the <code>TimeAndFormat</code> class (unless it&#8217;s used otherwise explicitly in the <code>SourceTargetMapper</code>). This can be resolved by defining <code>imports</code> on the <code>@Mapper</code> annotation.</p>
</div>
<div class="exampleblock">
<div class="title">Example 71. Declaring an import</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre>imports org.sample.TimeAndFormat;

<span class="annotation">@Mapper</span>( imports = TimeAndFormat.class )
<span class="directive">public</span> <span class="type">interface</span> <span class="class">SourceTargetMapper</span> {

    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );

    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">timeAndFormat</span><span class="delimiter">&quot;</span></span>,
         expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">java( new TimeAndFormat( s.getTime(), s.getFormat() ) )</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">Target</span> sourceToTarget(<span class="predefined-type">Source</span> s);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="default-expressions"><a class="anchor" href="#default-expressions"></a>10.3. Default Expressions</h3>
<div class="paragraph">
<p>Default expressions are a combination of default values and expressions. They will only be used when the source attribute is <code>null</code>.</p>
</div>
<div class="paragraph">
<p>The same warnings and restrictions apply to default expressions that apply to expressions. Only Java is supported, and MapStruct will not validate the expression at generation-time.</p>
</div>
<div class="paragraph">
<p>The example below demonstrates how two source properties can be mapped to one target:</p>
</div>
<div class="exampleblock">
<div class="title">Example 72. Mapping method using a default expression</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre>imports java.util.UUID;

<span class="annotation">@Mapper</span>( imports = <span class="predefined-type">UUID</span>.class )
<span class="directive">public</span> <span class="type">interface</span> <span class="class">SourceTargetMapper</span> {

    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );

    <span class="annotation">@Mapping</span>(target=<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>, source=<span class="string"><span class="delimiter">&quot;</span><span class="content">sourceId</span><span class="delimiter">&quot;</span></span>, defaultExpression = <span class="string"><span class="delimiter">&quot;</span><span class="content">java( UUID.randomUUID().toString() )</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">Target</span> sourceToTarget(<span class="predefined-type">Source</span> s);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The example demonstrates how to use defaultExpression to set an <code>ID</code> field if the source field is null, this could be used to take the existing <code>sourceId</code> from the source object if it is set, or create a new <code>Id</code> if it isn&#8217;t. Please note that the fully qualified package name is specified because MapStruct does not take care of the import of the <code>UUID</code> class (unless it’s used otherwise explicitly in the <code>SourceTargetMapper</code>). This can be resolved by defining imports on the @Mapper annotation (see <a href="#expressions">Expressions</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="determining-result-type"><a class="anchor" href="#determining-result-type"></a>10.4. Determining the result type</h3>
<div class="paragraph">
<p>When result types have an inheritance relation, selecting either mapping method (<code>@Mapping</code>) or a factory method (<code>@BeanMapping</code>) can become ambiguous. Suppose an Apple and a Banana, which are both specializations of Fruit.</p>
</div>
<div class="exampleblock">
<div class="title">Example 73. Specifying the result type of a bean mapping method</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>( uses = FruitFactory.class )
<span class="directive">public</span> <span class="type">interface</span> <span class="class">FruitMapper</span> {

    <span class="annotation">@BeanMapping</span>( resultType = Apple.class )
    Fruit map( FruitDto source );

}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">FruitFactory</span> {

    <span class="directive">public</span> Apple createApple() {
        <span class="keyword">return</span> <span class="keyword">new</span> Apple( <span class="string"><span class="delimiter">&quot;</span><span class="content">Apple</span><span class="delimiter">&quot;</span></span> );
    }

    <span class="directive">public</span> Banana createBanana() {
        <span class="keyword">return</span> <span class="keyword">new</span> Banana( <span class="string"><span class="delimiter">&quot;</span><span class="content">Banana</span><span class="delimiter">&quot;</span></span> );
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>So, which <code>Fruit</code> must be factorized in the mapping method <code>Fruit map(FruitDto source);</code>? A <code>Banana</code> or an <code>Apple</code>? Here&#8217;s where the <code>@BeanMapping#resultType</code> comes in handy. It controls the factory method to select, or in absence of a factory method, the return type to create.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The same mechanism is present on mapping: <code>@Mapping#resultType</code> and works like you expect it would: it selects the mapping method with the desired result type when present.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The mechanism is also present on iterable mapping and map mapping. <code>@IterableMapping#elementTargetType</code> is used to select the mapping method with the desired element in the resulting <code>Iterable</code>. For the <code>@MapMapping</code> a similar purpose is served by means of <code>#MapMapping#keyTargetType</code> and <code>MapMapping#valueTargetType</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mapping-result-for-null-arguments"><a class="anchor" href="#mapping-result-for-null-arguments"></a>10.5. Controlling mapping result for 'null' arguments</h3>
<div class="paragraph">
<p>MapStruct offers control over the object to create when the source argument of the mapping method equals <code>null</code>. By default <code>null</code> will be returned.</p>
</div>
<div class="paragraph">
<p>However, by specifying <code>nullValueMappingStrategy = NullValueMappingStrategy.RETURN_DEFAULT</code> on <code>@BeanMapping</code>, <code>@IterableMapping</code>, <code>@MapMapping</code>, or globally on <code>@Mapper</code> or <code>@MapperConfig</code>, the mapping result can be altered to return empty <strong>default</strong> values. This means for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bean mappings</strong>: an 'empty' target bean will be returned, with the exception of constants and expressions, they will be populated when present.</p>
</li>
<li>
<p><strong>Iterables / Arrays</strong>: an empty iterable will be returned.</p>
</li>
<li>
<p><strong>Maps</strong>: an empty map will be returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The strategy works in a hierarchical fashion. Setting <code>nullValueMappingStrategy</code> on mapping method level will override <code>@Mapper#nullValueMappingStrategy</code>, and <code>@Mapper#nullValueMappingStrategy</code> will override <code>@MapperConfig#nullValueMappingStrategy</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mapping-result-for-null-properties"><a class="anchor" href="#mapping-result-for-null-properties"></a>10.6. Controlling mapping result for 'null' properties in bean mappings (update mapping methods only).</h3>
<div class="paragraph">
<p>MapStruct offers control over the property to set in an <code>@MappingTarget</code> annotated target bean when the source property equals <code>null</code> or the presence check method results in 'absent'.</p>
</div>
<div class="paragraph">
<p>By default the target property will be set to null.</p>
</div>
<div class="paragraph">
<p>However:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>By specifying <code>nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.SET_TO_DEFAULT</code> on <code>@Mapping</code>, <code>@BeanMapping</code>, <code>@Mapper</code> or <code>@MapperConfig</code>, the mapping result can be altered to return <strong>default</strong> values.
For <code>List</code> MapStruct generates an <code>ArrayList</code>, for <code>Map</code> a <code>HashMap</code>, for arrays an empty array, for <code>String</code> <code>""</code> and for primitive / boxed types a representation of <code>false</code> or <code>0</code>.
For all other objects an new instance is created. Please note that a default constructor is required. If not available, use the <code>@Mapping#defaultValue</code>.</p>
</li>
<li>
<p>By specifying <code>nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE</code> on <code>@Mapping</code>, <code>@BeanMapping</code>, <code>@Mapper</code> or <code>@MapperConfig</code>, the mapping result will be equal to the original value of the <code>@MappingTarget</code> annotated target.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The strategy works in a hierarchical fashion. Setting <code>nullValuePropertyMappingStrategy</code> on mapping method level will override <code>@Mapper#nullValuePropertyMappingStrategy</code>, and <code>@Mapper#nullValuePropertyMappingStrategy</code> will override <code>@MapperConfig#nullValuePropertyMappingStrategy</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some types of mappings (collections, maps), in which MapStruct is instructed to use a getter or adder as target accessor (see <code>CollectionMappingStrategy</code>), MapStruct will always generate a source property
null check, regardless of the value of the <code>NullValuePropertyMappingStrategy</code>, to avoid addition of <code>null</code> to the target collection or map. Since the target is assumed to be initialised this strategy will not be applied.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>NullValuePropertyMappingStrategy</code> also applies when the presence checker returns <code>not present</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="checking-source-property-for-null-arguments"><a class="anchor" href="#checking-source-property-for-null-arguments"></a>10.7. Controlling checking result for 'null' properties in bean mapping</h3>
<div class="paragraph">
<p>MapStruct offers control over when to generate a <code>null</code> check. By default (<code>nullValueCheckStrategy = NullValueCheckStrategy.ON_IMPLICIT_CONVERSION</code>) a <code>null</code> check will be generated for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>direct setting of source value to target value when target is primitive and source is not.</p>
</li>
<li>
<p>applying type conversion and then:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>calling the setter on the target.</p>
</li>
<li>
<p>calling another type conversion and subsequently calling the setter on the target.</p>
</li>
<li>
<p>calling a mapping method and subsequently calling the setter on the target.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>First calling a mapping method on the source property is not protected by a null check. Therefore generated mapping methods will do a null check prior to carrying out mapping on a source property. Handwritten mapping methods must take care of null value checking. They have the possibility to add 'meaning' to <code>null</code>. For instance: mapping <code>null</code> to a default value.</p>
</div>
<div class="paragraph">
<p>The option <code>nullValueCheckStrategy = NullValueCheckStrategy.ALWAYS</code> will always include a null check when source is non primitive, unless a source presence checker is defined on the source bean.</p>
</div>
<div class="paragraph">
<p>The strategy works in a hierarchical fashion. <code>@Mapping#nullValueCheckStrategy</code> will override <code>@BeanMapping#nullValueCheckStrategy</code>, <code>@BeanMapping#nullValueCheckStrategy</code> will override <code>@Mapper#nullValueCheckStrategy</code> and <code>@Mapper#nullValueCheckStrategy</code> will override <code>@MaperConfig#nullValueCheckStrategy</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="source-presence-check"><a class="anchor" href="#source-presence-check"></a>10.8. Source presence checking</h3>
<div class="paragraph">
<p>Some frameworks generate bean properties that have a source presence checker. Often this is in the form of a method <code>hasXYZ</code>, <code>XYZ</code> being a property on the source bean in a bean mapping method. MapStruct will call this <code>hasXYZ</code> instead of performing a <code>null</code> check when it finds such <code>hasXYZ</code> method.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The source presence checker name can be changed in the MapStruct service provider interface (SPI). It can also be deactivated in this way.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some types of mappings (collections, maps), in which MapStruct is instructed to use a getter or adder as target accessor see <code>CollectionMappingStrategy</code>, MapStruct will always generate a source property
null check, regardless the value of the <code>NullValueCheckStrategy</code> to avoid addition of <code>null</code> to the target collection or map.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="exceptions"><a class="anchor" href="#exceptions"></a>10.9. Exceptions</h3>
<div class="paragraph">
<p>Calling applications may require handling of exceptions when calling a mapping method. These exceptions could be thrown by hand-written logic and by the generated built-in mapping methods or type-conversions of MapStruct. When the calling application requires handling of exceptions, a throws clause can be defined in the mapping method:</p>
</div>
<div class="exampleblock">
<div class="title">Example 74. Mapper using custom method declaring checked exception</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>(uses = HandWritten.class)
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    CarDto carToCarDto(Car car) <span class="directive">throws</span> GearException;
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The hand written logic might look like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 75. Custom mapping method declaring checked exception</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">HandWritten</span> {

    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> GEAR = {<span class="string"><span class="delimiter">&quot;</span><span class="content">ONE</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">TWO</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">THREE</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">OVERDRIVE</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">REVERSE</span><span class="delimiter">&quot;</span></span>};

    <span class="directive">public</span> <span class="predefined-type">String</span> toGear(<span class="predefined-type">Integer</span> gear) <span class="directive">throws</span> GearException, FatalException {
        <span class="keyword">if</span> ( gear == <span class="predefined-constant">null</span> ) {
            <span class="keyword">throw</span> <span class="keyword">new</span> FatalException(<span class="string"><span class="delimiter">&quot;</span><span class="content">null is not a valid gear</span><span class="delimiter">&quot;</span></span>);
        }

        <span class="keyword">if</span> ( gear &lt; <span class="integer">0</span> &amp;&amp; gear &gt; GEAR.length ) {
            <span class="keyword">throw</span> <span class="keyword">new</span> GearException(<span class="string"><span class="delimiter">&quot;</span><span class="content">invalid gear</span><span class="delimiter">&quot;</span></span>);
        }
        <span class="keyword">return</span> GEAR[gear];
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>MapStruct now, wraps the <code>FatalException</code> in a <code>try-catch</code> block and rethrows an unchecked <code>RuntimeException</code>. MapStruct delegates handling of the <code>GearException</code> to the application logic because it is defined as throws clause in the <code>carToCarDto</code> method:</p>
</div>
<div class="exampleblock">
<div class="title">Example 76. try-catch block in generated implementation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre><span class="comment">// GENERATED CODE</span>
<span class="annotation">@Override</span>
<span class="directive">public</span> CarDto carToCarDto(Car car) <span class="directive">throws</span> GearException {
    <span class="keyword">if</span> ( car == <span class="predefined-constant">null</span> ) {
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

    CarDto carDto = <span class="keyword">new</span> CarDto();
    <span class="keyword">try</span> {
        carDto.setGear( handWritten.toGear( car.getGear() ) );
    }
    <span class="keyword">catch</span> ( FatalException e ) {
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>( e );
    }

    <span class="keyword">return</span> carDto;
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Some <strong>notes</strong> on null checks. MapStruct does provide null checking only when required: when applying type-conversions or constructing a new type by invoking its constructor. This means that the user is responsible in hand-written code for returning valid non-null objects. Also null objects can be handed to hand-written code, since MapStruct does not want to make assumptions on the meaning assigned by the user to a null object. Hand-written code has to deal with this.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reusing_mapping_configurations"><a class="anchor" href="#_reusing_mapping_configurations"></a>11. Reusing mapping configurations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter discusses different means of reusing mapping configurations for several mapping methods: "inheritance" of configuration from other methods and sharing central configuration between multiple mapper types.</p>
</div>
<div class="sect2">
<h3 id="mapping-configuration-inheritance"><a class="anchor" href="#mapping-configuration-inheritance"></a>11.1. Mapping configuration inheritance</h3>
<div class="paragraph">
<p>Method-level configuration annotations such as <code>@Mapping</code>, <code>@BeanMapping</code>, <code>@IterableMapping</code>, etc., can be <strong>inherited</strong> from one mapping method to a <strong>similar</strong> method using the annotation <code>@InheritConfiguration</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 77. Update method inheriting its configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">numberOfSeats</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">seatCount</span><span class="delimiter">&quot;</span></span>)
    Car carDtoToCar(CarDto car);

    <span class="annotation">@InheritConfiguration</span>
    <span class="type">void</span> carDtoIntoCar(CarDto carDto, <span class="annotation">@MappingTarget</span> Car car);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The example above declares a mapping method <code>carDtoToCar()</code> with a configuration to define how the property <code>numberOfSeats</code> in the type <code>Car</code> shall be mapped. The update method that performs the mapping on an existing instance of <code>Car</code> needs the same configuration to successfully map all properties. Declaring <code>@InheritConfiguration</code> on the method lets MapStruct search for inheritance candidates to apply the annotations of the method that is inherited from.</p>
</div>
<div class="paragraph">
<p>One method <strong>A</strong> can inherit the configuration from another method <strong>B</strong> if all types of <strong>A</strong> (source types and result type) are assignable to the corresponding types of <strong>B</strong>.</p>
</div>
<div class="paragraph">
<p>Methods that are considered for inheritance need to be defined in the current mapper, a super class/interface, or in the shared configuration interface (as described in <a href="#shared-configurations">Shared configurations</a>).</p>
</div>
<div class="paragraph">
<p>In case more than one method is applicable as source for the inheritance, the method name must be specified within the annotation: <code>@InheritConfiguration( name = "carDtoToCar" )</code>.</p>
</div>
<div class="paragraph">
<p>A method can use <code>@InheritConfiguration</code> and override or amend the configuration by additionally applying <code>@Mapping</code>, <code>@BeanMapping</code>, etc.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@InheritConfiguration</code> cannot refer to methods in a used mapper.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="inverse-mappings"><a class="anchor" href="#inverse-mappings"></a>11.2. Inverse mappings</h3>
<div class="paragraph">
<p>In case of bi-directional mappings, e.g. from entity to DTO and from DTO to entity, the mapping rules for the forward method and the reverse method are often similar and can simply be inversed by switching <code>source</code> and <code>target</code>.</p>
</div>
<div class="paragraph">
<p>Use the annotation <code>@InheritInverseConfiguration</code> to indicate that a method shall inherit the inverse configuration of the corresponding reverse method.</p>
</div>
<div class="exampleblock">
<div class="title">Example 78. Inverse mapping method inheriting its configuration and ignoring some of them</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CarMapper</span> {

    <span class="annotation">@Mapping</span>(source = <span class="string"><span class="delimiter">&quot;</span><span class="content">numberOfSeats</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">seatCount</span><span class="delimiter">&quot;</span></span>)
    CarDto carToDto(Car car);

    <span class="annotation">@InheritInverseConfiguration</span>
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">numberOfSeats</span><span class="delimiter">&quot;</span></span>, ignore = <span class="predefined-constant">true</span>)
    Car carDtoToCar(CarDto carDto);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Here the <code>carDtoToCar()</code> method is the reverse mapping method for <code>carToDto()</code>. Note that any attribute mappings from <code>carToDto()</code> will be applied to the corresponding reverse mapping method as well. They are automatically reversed and copied to the method with the <code>@InheritInverseConfiguration</code> annotation.</p>
</div>
<div class="paragraph">
<p>Specific mappings from the inversed method can (optionally) be overridden by  <code>ignore</code>, <code>expression</code> or <code>constant</code> in the mapping, e.g. like this: <code>@Mapping(target = "numberOfSeats", ignore=true)</code>.</p>
</div>
<div class="paragraph">
<p>A method <strong>A</strong> is considered a <strong>reverse</strong> method of a method <strong>B</strong>, if the result type of <strong>A</strong> is the <strong>same</strong> as the single source type of <strong>B</strong> and if the single source type of <strong>A</strong> is the <strong>same</strong> as the result type of <strong>B</strong>.</p>
</div>
<div class="paragraph">
<p>Methods that are considered for inverse inheritance need to be defined in the current mapper, a super class/interface.</p>
</div>
<div class="paragraph">
<p>If multiple methods qualify, the method from which to inherit the configuration needs to be specified using the <code>name</code> property like this: <code>@InheritInverseConfiguration(name = "carToDto")</code>.</p>
</div>
<div class="paragraph">
<p><code>@InheritConfiguration</code> takes, in case of conflict precedence over <code>@InheritInverseConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>Configurations are inherited transitively. So if method <code>C</code> defines a mapping <code>@Mapping( target = "x", ignore = true)</code>, <code>B</code> defines a mapping <code>@Mapping( target = "y", ignore = true)</code>, then if <code>A</code> inherits from <code>B</code> inherits from <code>C</code>, <code>A</code> will inherit mappings for both property <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p><code>@Mapping#expression</code>, <code>@Mapping#defaultExpression</code>, <code>@Mapping#defaultValue</code> and <code>@Mapping#constant</code> are excluded (silently ignored) in <code>@InheritInverseConfiguration</code>.</p>
</div>
<div class="paragraph">
<p><code>@Mapping#ignore</code> is only applied when <code>@Mapping#source</code> is also present in <code>@InheritInverseConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>Reverse mapping of nested source properties is experimental as of the 1.1.0.Beta2 release. Reverse mapping will take place automatically when the source property name and target property name are identical. Otherwise, <code>@Mapping</code> should specify both the target name and source name. In all cases, a suitable mapping method needs to be in place for the reverse mapping.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@InheritInverseConfiguration</code> cannot refer to methods in a used mapper.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="shared-configurations"><a class="anchor" href="#shared-configurations"></a>11.3. Shared configurations</h3>
<div class="paragraph">
<p>MapStruct offers the possibility to define a shared configuration by pointing to a central interface annotated with <code>@MapperConfig</code>. For a mapper to use the shared configuration, the configuration interface needs to be defined in the <code>@Mapper#config</code> property.</p>
</div>
<div class="paragraph">
<p>The <code>@MapperConfig</code> annotation has the same attributes as the <code>@Mapper</code> annotation. Any attributes not given via <code>@Mapper</code> will be inherited from the shared configuration. Attributes specified in <code>@Mapper</code> take precedence over the attributes specified via the referenced configuration class. List properties such as <code>uses</code> are simply combined:</p>
</div>
<div class="exampleblock">
<div class="title">Example 79. Mapper configuration class and mapper using it</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="annotation">@MapperConfig</span>(
    uses = CustomMapperViaMapperConfig.class,
    unmappedTargetPolicy = ReportingPolicy.ERROR
)
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CentralConfig</span> {
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>(config = CentralConfig.class, uses = { CustomMapperViaMapper.class } )
<span class="comment">// Effective configuration:</span>
<span class="comment">// @Mapper(</span>
<span class="comment">//     uses = { CustomMapperViaMapper.class, CustomMapperViaMapperConfig.class },</span>
<span class="comment">//     unmappedTargetPolicy = ReportingPolicy.ERROR</span>
<span class="comment">// )</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">SourceTargetMapper</span> {
  ...
}
</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The interface holding the <code>@MapperConfig</code> annotation may also declare <strong>prototypes</strong> of mapping methods that can be used to inherit method-level mapping annotations from. Such prototype methods are not meant to be implemented or used as part of the mapper API.</p>
</div>
<div class="exampleblock">
<div class="title">Example 80. Mapper configuration class with prototype methods</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="annotation">@MapperConfig</span>(
    uses = CustomMapperViaMapperConfig.class,
    unmappedTargetPolicy = ReportingPolicy.ERROR,
    mappingInheritanceStrategy = MappingInheritanceStrategy.AUTO_INHERIT_FROM_CONFIG
)
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CentralConfig</span> {

    <span class="comment">// Not intended to be generated, but to carry inheritable mapping annotations:</span>
    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">primaryKey</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">technicalKey</span><span class="delimiter">&quot;</span></span>)
    BaseEntity anyDtoToEntity(BaseDto dto);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>(config = CentralConfig.class, uses = { CustomMapperViaMapper.class } )
<span class="directive">public</span> <span class="type">interface</span> <span class="class">SourceTargetMapper</span> {

    <span class="annotation">@Mapping</span>(target = <span class="string"><span class="delimiter">&quot;</span><span class="content">numberOfSeats</span><span class="delimiter">&quot;</span></span>, source = <span class="string"><span class="delimiter">&quot;</span><span class="content">seatCount</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// additionally inherited from CentralConfig, because Car extends BaseEntity and CarDto extends BaseDto:</span>
    <span class="comment">// @Mapping(target = &quot;primaryKey&quot;, source = &quot;technicalKey&quot;)</span>
    Car toCar(CarDto car)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The attributes <code>@Mapper#mappingInheritanceStrategy()</code> / <code>@MapperConfig#mappingInheritanceStrategy()</code> configure when the method-level mapping configuration annotations are inherited from prototype methods in the interface to methods in the mapper:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EXPLICIT</code> (default): the configuration will only be inherited, if the target mapping method is annotated with <code>@InheritConfiguration</code> and the source and target types are assignable to the corresponding types of the prototype method, all as described in <a href="#mapping-configuration-inheritance">Mapping configuration inheritance</a>.</p>
</li>
<li>
<p><code>AUTO_INHERIT_FROM_CONFIG</code>: the configuration will be inherited automatically, if the source and target types of the target mapping method are assignable to the corresponding types of the prototype method. If multiple prototype methods match, the ambiguity must be resolved using <code>@InheritConfiguration(name = &#8230;&#8203;)</code> which will cause <code>AUTO_INHERIT_FROM_CONFIG</code> to be ignored.</p>
</li>
<li>
<p><code>AUTO_INHERIT_REVERSE_FROM_CONFIG</code>: the inverse configuration will be inherited automatically, if the source and target types of the target mapping method are assignable to the corresponding types of the prototype method. If multiple prototype methods match, the ambiguity must be resolved using <code>@InheritInverseConfiguration(name = &#8230;&#8203;)</code> which will cause <code>`AUTO_INHERIT_REVERSE_FROM_CONFIG</code> to be ignored.</p>
</li>
<li>
<p><code>AUTO_INHERIT_ALL_FROM_CONFIG</code>: both the configuration and the inverse configuration will be inherited automatically. The same rules apply as for <code>AUTO_INHERIT_FROM_CONFIG</code> or <code>AUTO_INHERIT_REVERSE_FROM_CONFIG</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_customizing_mappings"><a class="anchor" href="#_customizing_mappings"></a>12. Customizing mappings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes it&#8217;s needed to apply custom logic before or after certain mapping methods. MapStruct provides two ways for doing so: decorators which allow for a type-safe customization of specific mapping methods and the before-mapping and after-mapping lifecycle methods which allow for a generic customization of mapping methods with given source or target types.</p>
</div>
<div class="sect2">
<h3 id="customizing-mappers-using-decorators"><a class="anchor" href="#customizing-mappers-using-decorators"></a>12.1. Mapping customization with decorators</h3>
<div class="paragraph">
<p>In certain cases it may be required to customize a generated mapping method, e.g. to set an additional property in the target object which can&#8217;t be set by a generated method implementation. MapStruct supports this requirement using decorators.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When working with the component model <code>cdi</code>, use <a href="https://docs.jboss.org/cdi/spec/1.0/html/decorators.html">CDI decorators</a> with MapStruct mappers instead of the <code>@DecoratedWith</code> annotation described here.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To apply a decorator to a mapper class, specify it using the <code>@DecoratedWith</code> annotation.</p>
</div>
<div class="exampleblock">
<div class="title">Example 81. Applying a decorator</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="annotation">@DecoratedWith</span>(PersonMapperDecorator.class)
<span class="directive">public</span> <span class="type">interface</span> <span class="class">PersonMapper</span> {

    PersonMapper INSTANCE = Mappers.getMapper( PersonMapper.class );

    PersonDto personToPersonDto(Person person);

    AddressDto addressToAddressDto(Address address);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The decorator must be a sub-type of the decorated mapper type. You can make it an abstract class which allows to only implement those methods of the mapper interface which you want to customize. For all non-implemented methods, a simple delegation to the original mapper will be generated using the default generation routine.</p>
</div>
<div class="paragraph">
<p>The <code>PersonMapperDecorator</code> shown below customizes the <code>personToPersonDto()</code>. It sets an additional attribute which is not present in the source type of the mapping. The <code>addressToAddressDto()</code> method is not customized.</p>
</div>
<div class="exampleblock">
<div class="title">Example 82. Implementing a decorator</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">PersonMapperDecorator</span> <span class="directive">implements</span> PersonMapper {

    <span class="directive">private</span> <span class="directive">final</span> PersonMapper delegate;

    <span class="directive">public</span> PersonMapperDecorator(PersonMapper delegate) {
        <span class="local-variable">this</span>.delegate = delegate;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> PersonDto personToPersonDto(Person person) {
        PersonDto dto = delegate.personToPersonDto( person );
        dto.setFullName( person.getFirstName() + <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> + person.getLastName() );
        <span class="keyword">return</span> dto;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The example shows how you can optionally inject a delegate with the generated default implementation and use this delegate in your customized decorator methods.</p>
</div>
<div class="paragraph">
<p>For a mapper with <code>componentModel = "default"</code>, define a constructor with a single parameter which accepts the type of the decorated mapper.</p>
</div>
<div class="paragraph">
<p>When working with the component models <code>spring</code> or <code>jsr330</code>, this needs to be handled differently.</p>
</div>
<div class="sect3">
<h4 id="decorators-with-spring"><a class="anchor" href="#decorators-with-spring"></a>12.1.1. Decorators with the Spring component model</h4>
<div class="paragraph">
<p>When using <code>@DecoratedWith</code> on a mapper with component model <code>spring</code>, the generated implementation of the original mapper is annotated with the Spring annotation <code>@Qualifier("delegate")</code>. To autowire that bean in your decorator, add that qualifier annotation as well:</p>
</div>
<div class="exampleblock">
<div class="title">Example 83. Spring-based decorator</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">PersonMapperDecorator</span> <span class="directive">implements</span> PersonMapper {

     <span class="annotation">@Autowired</span>
     <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">delegate</span><span class="delimiter">&quot;</span></span>)
     <span class="directive">private</span> PersonMapper delegate;

     <span class="annotation">@Override</span>
     <span class="directive">public</span> PersonDto personToPersonDto(Person person) {
         PersonDto dto = delegate.personToPersonDto( person );
         dto.setName( person.getFirstName() + <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> + person.getLastName() );

         <span class="keyword">return</span> dto;
     }
 }</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The generated class that extends the decorator is annotated with Spring&#8217;s <code>@Primary</code> annotation. To autowire the decorated mapper in the application, nothing special needs to be done:</p>
</div>
<div class="exampleblock">
<div class="title">Example 84. Using a decorated mapper</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="annotation">@Autowired</span>
<span class="directive">private</span> PersonMapper personMapper; <span class="comment">// injects the decorator, with the injected original mapper</span></pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="decorators-with-jsr-330"><a class="anchor" href="#decorators-with-jsr-330"></a>12.1.2. Decorators with the JSR 330 component model</h4>
<div class="paragraph">
<p>JSR 330 doesn&#8217;t specify qualifiers and only allows to specifically name the beans. Hence, the generated implementation of the original mapper is annotated with <code>@Named("fully-qualified-name-of-generated-implementation")</code> (please note that when using a decorator, the class name of the mapper implementation ends with an underscore). To inject that bean in your decorator, add the same annotation to the delegate field (e.g. by copy/pasting it from the generated class):</p>
</div>
<div class="exampleblock">
<div class="title">Example 85. JSR 330 based decorator</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">PersonMapperDecorator</span> <span class="directive">implements</span> PersonMapper {

    <span class="annotation">@Inject</span>
    <span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.examples.PersonMapperImpl_</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> PersonMapper delegate;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> PersonDto personToPersonDto(Person person) {
        PersonDto dto = delegate.personToPersonDto( person );
        dto.setName( person.getFirstName() + <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> + person.getLastName() );

        <span class="keyword">return</span> dto;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Unlike with the other component models, the usage site must be aware if a mapper is decorated or not, as for decorated mappers, the parameterless <code>@Named</code> annotation must be added to select the decorator to be injected:</p>
</div>
<div class="exampleblock">
<div class="title">Example 86. Using a decorated mapper with JSR 330</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="annotation">@Inject</span>
<span class="annotation">@Named</span>
<span class="directive">private</span> PersonMapper personMapper; <span class="comment">// injects the decorator, with the injected original mapper</span></pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="customizing-mappings-with-before-and-after"><a class="anchor" href="#customizing-mappings-with-before-and-after"></a>12.2. Mapping customization with before-mapping and after-mapping methods</h3>
<div class="paragraph">
<p>Decorators may not always fit the needs when it comes to customizing mappers. For example, if you need to perform the customization not only for a few selected methods, but for all methods that map specific super-types: in that case, you can use <strong>callback methods</strong> that are invoked before the mapping starts or after the mapping finished.</p>
</div>
<div class="paragraph">
<p>Callback methods can be implemented in the abstract mapper itself, in a type reference in <code>Mapper#uses</code>, or in a type used as <code>@Context</code> parameter.</p>
</div>
<div class="exampleblock">
<div class="title">Example 87. Mapper with @BeforeMapping and @AfterMapping hooks</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">VehicleMapper</span> {

    <span class="annotation">@BeforeMapping</span>
    <span class="directive">protected</span> <span class="type">void</span> flushEntity(AbstractVehicle vehicle) {
        <span class="comment">// I would call my entity manager's flush() method here to make sure my entity</span>
        <span class="comment">// is populated with the right @Version before I let it map into the DTO</span>
    }

    <span class="annotation">@AfterMapping</span>
    <span class="directive">protected</span> <span class="type">void</span> fillTank(AbstractVehicle vehicle, <span class="annotation">@MappingTarget</span> AbstractVehicleDto result) {
        result.fuelUp( <span class="keyword">new</span> Fuel( vehicle.getTankCapacity(), vehicle.getFuelType() ) );
    }

    <span class="directive">public</span> <span class="directive">abstract</span> CarDto toCarDto(Car car);
}

<span class="comment">// Generates something like this:</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">VehicleMapperImpl</span> <span class="directive">extends</span> VehicleMapper {

    <span class="directive">public</span> CarDto toCarDto(Car car) {
        flushEntity( car );

        <span class="keyword">if</span> ( car == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        CarDto carDto = <span class="keyword">new</span> CarDto();
        <span class="comment">// attributes mapping ...</span>

        fillTank( car, carDto );

        <span class="keyword">return</span> carDto;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the <code>@BeforeMapping</code> / <code>@AfterMapping</code> method has parameters, the method invocation is only generated if the return type of the method (if non-<code>void</code>) is assignable to the return type of the mapping method and all parameters can be <strong>assigned</strong> by the source or target parameters of the mapping method:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A parameter annotated with <code>@MappingTarget</code> is populated with the target instance of the mapping.</p>
</li>
<li>
<p>A parameter annotated with <code>@TargetType</code> is populated with the target type of the mapping.</p>
</li>
<li>
<p>Parameters annotated with <code>@Context</code> are populated with the context parameters of the mapping method.</p>
</li>
<li>
<p>Any other parameter is populated with a source parameter of the mapping.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For non-<code>void</code> methods, the return value of the method invocation is returned as the result of the mapping method if it is not <code>null</code>.</p>
</div>
<div class="paragraph">
<p>As with mapping methods, it is possible to specify type parameters for before/after-mapping methods.</p>
</div>
<div class="exampleblock">
<div class="title">Example 88. Mapper with @AfterMapping hook that returns a non-null value</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">VehicleMapper</span> {

    <span class="annotation">@PersistenceContext</span>
    <span class="directive">private</span> EntityManager entityManager;

    <span class="annotation">@AfterMapping</span>
    <span class="directive">protected</span> &lt;T&gt; T attachEntity(<span class="annotation">@MappingTarget</span> T entity) {
        <span class="keyword">return</span> entityManager.merge(entity);
    }

    <span class="directive">public</span> <span class="directive">abstract</span> CarDto toCarDto(Car car);
}

<span class="comment">// Generates something like this:</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">VehicleMapperImpl</span> <span class="directive">extends</span> VehicleMapper {

    <span class="directive">public</span> CarDto toCarDto(Car car) {
        <span class="keyword">if</span> ( car == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        CarDto carDto = <span class="keyword">new</span> CarDto();
        <span class="comment">// attributes mapping ...</span>

        CarDto target = attachEntity( carDto );
        <span class="keyword">if</span> ( target != <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> target;
        }

        <span class="keyword">return</span> carDto;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>All before/after-mapping methods that <strong>can</strong> be applied to a mapping method <strong>will</strong> be used. <a href="#selection-based-on-qualifiers">Mapping method selection based on qualifiers</a> can be used to further control which methods may be chosen and which not. For that, the qualifier annotation needs to be applied to the before/after-method and referenced in <code>BeanMapping#qualifiedBy</code> or <code>IterableMapping#qualifiedBy</code>.</p>
</div>
<div class="paragraph">
<p>The order of the method invocation is determined primarily by their variant:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>@BeforeMapping</code> methods without an <code>@MappingTarget</code> parameter are called before any null-checks on source
parameters and constructing a new target bean.</p>
</li>
<li>
<p><code>@BeforeMapping</code> methods with an <code>@MappingTarget</code> parameter are called after constructing a new target bean.</p>
</li>
<li>
<p><code>@AfterMapping</code> methods are called at the end of the mapping method before the last <code>return</code> statement.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Within those groups, the method invocations are ordered by their location of definition:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Methods declared on <code>@Context</code> parameters, ordered by the parameter order.</p>
</li>
<li>
<p>Methods implemented in the mapper itself.</p>
</li>
<li>
<p>Methods from types referenced in <code>Mapper#uses()</code>, in the order of the type declaration in the annotation.</p>
</li>
<li>
<p>Methods declared in one type are used after methods declared in their super-type.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Important:</strong> the order of methods declared within one type can not be guaranteed, as it depends on the compiler and the processing environment implementation.</p>
</div>
<div class="paragraph">
<p><strong>Important:</strong> when using a builder, the <code>@AfterMapping</code> annotated method must have the builder as <code>@MappingTarget</code> annotated parameter so that the method is able to modify the object going to be build. The <code>build</code> method is called when the <code>@AfterMapping</code> annotated method scope finishes. MapStruct will not call the <code>@AfterMapping</code> annotated method if the real target is used as <code>@MappingTarget</code> annotated parameter.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-spi"><a class="anchor" href="#using-spi"></a>13. Using the MapStruct SPI</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_custom_accessor_naming_strategy"><a class="anchor" href="#_custom_accessor_naming_strategy"></a>13.1. Custom Accessor Naming Strategy</h3>
<div class="paragraph">
<p>MapStruct offers the possibility to override the <code>AccessorNamingStrategy</code> via the Service Provider Interface (SPI). A nice example is the use of the fluent API on the source object <code>GolfPlayer</code> and <code>GolfPlayerDto</code> below.</p>
</div>
<div class="exampleblock">
<div class="title">Example 89. Source object GolfPlayer with fluent API.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">GolfPlayer</span> {

    <span class="directive">private</span> <span class="type">double</span> handicap;
    <span class="directive">private</span> <span class="predefined-type">String</span> name;

    <span class="directive">public</span> <span class="type">double</span> handicap() {
        <span class="keyword">return</span> handicap;
    }

    <span class="directive">public</span> GolfPlayer withHandicap(<span class="type">double</span> handicap) {
        <span class="local-variable">this</span>.handicap = handicap;
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> name() {
        <span class="keyword">return</span> name;
    }

    <span class="directive">public</span> GolfPlayer withName(<span class="predefined-type">String</span> name) {
        <span class="local-variable">this</span>.name = name;
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 90. Source object GolfPlayerDto with fluent API.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">GolfPlayerDto</span> {

    <span class="directive">private</span> <span class="type">double</span> handicap;
    <span class="directive">private</span> <span class="predefined-type">String</span> name;

    <span class="directive">public</span> <span class="type">double</span> handicap() {
        <span class="keyword">return</span> handicap;
    }

    <span class="directive">public</span> GolfPlayerDto withHandicap(<span class="type">double</span> handicap) {
        <span class="local-variable">this</span>.handicap = handicap;
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> name() {
        <span class="keyword">return</span> name;
    }

    <span class="directive">public</span> GolfPlayerDto withName(<span class="predefined-type">String</span> name) {
        <span class="local-variable">this</span>.name = name;
        <span class="keyword">return</span> <span class="local-variable">this</span>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We want <code>GolfPlayer</code> to be mapped to a target object <code>GolfPlayerDto</code> similar like we 'always' do this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 91. Source object with fluent API.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">GolfPlayerMapper</span> {

    GolfPlayerMapper INSTANCE = Mappers.getMapper( GolfPlayerMapper.class );

    GolfPlayerDto toDto(GolfPlayer player);

    GolfPlayer toPlayer(GolfPlayerDto player);

}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This can be achieved with implementing the SPI <code>org.mapstruct.ap.spi.AccessorNamingStrategy</code> as in the following example. Here&#8217;s an implemented <code>org.mapstruct.ap.spi.AccessorNamingStrategy</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 92. CustomAccessorNamingStrategy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="comment">/**
 * A custom {@link AccessorNamingStrategy} recognizing getters in the form of {@code property()} and setters in the
 * form of {@code withProperty(value)}.
 */</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CustomAccessorNamingStrategy</span> <span class="directive">extends</span> DefaultAccessorNamingStrategy {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> isGetterMethod(ExecutableElement method) {
        <span class="predefined-type">String</span> methodName = method.getSimpleName().toString();
        <span class="keyword">return</span> !methodName.startsWith( <span class="string"><span class="delimiter">&quot;</span><span class="content">with</span><span class="delimiter">&quot;</span></span> ) &amp;&amp; method.getReturnType().getKind() != TypeKind.VOID;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> isSetterMethod(ExecutableElement method) {
        <span class="predefined-type">String</span> methodName = method.getSimpleName().toString();
        <span class="keyword">return</span> methodName.startsWith( <span class="string"><span class="delimiter">&quot;</span><span class="content">with</span><span class="delimiter">&quot;</span></span> ) &amp;&amp; methodName.length() &gt; <span class="integer">4</span>;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getPropertyName(ExecutableElement getterOrSetterMethod) {
        <span class="predefined-type">String</span> methodName = getterOrSetterMethod.getSimpleName().toString();
        <span class="keyword">return</span> IntrospectorUtils.decapitalize( methodName.startsWith( <span class="string"><span class="delimiter">&quot;</span><span class="content">with</span><span class="delimiter">&quot;</span></span> ) ? methodName.substring(  <span class="integer">4</span> ) : methodName );
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>CustomAccessorNamingStrategy</code> makes use of the <code>DefaultAccessorNamingStrategy</code> (also available in mapstruct-processor) and relies on that class to leave most of the default behaviour unchanged.</p>
</div>
<div class="paragraph">
<p>To use a custom SPI implementation, it must be located in a separate JAR file together with the file <code>META-INF/services/org.mapstruct.ap.spi.AccessorNamingStrategy</code> with the fully qualified name of your custom implementation as content (e.g. <code>org.mapstruct.example.CustomAccessorNamingStrategy</code>). This JAR file needs to be added to the annotation processor classpath (i.e. add it next to the place where you added the mapstruct-processor jar).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Fore more details: The example above is present in our examples repository (<a href="https://github.com/mapstruct/mapstruct-examples" class="bare">https://github.com/mapstruct/mapstruct-examples</a>).
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_mapping_exclusion_provider"><a class="anchor" href="#_mapping_exclusion_provider"></a>Mapping Exclusion Provider</h3>
<div class="paragraph">
<p>MapStruct offers the possibility to override the <code>MappingExclusionProvider</code> via the Service Provider Interface (SPI).
A nice example is to not allow MapStruct to create an automatic sub-mapping for a certain type,
i.e. MapStruct will not try to generate an automatic sub-mapping method for an excluded type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>DefaultMappingExclusionProvider</code> will exclude all types under the <code>java</code> or <code>javax</code> packages.
This means that MapStruct will not try to generate an automatic sub-mapping method between some custom type and some type declared in the Java class library.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 93. Source object</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">Source</span> {

    <span class="directive">static</span> <span class="type">class</span> <span class="class">NestedSource</span> {
        <span class="directive">private</span> <span class="predefined-type">String</span> property;
        <span class="comment">// getters and setters</span>
    }

    <span class="directive">private</span> NestedSource nested;
    <span class="comment">// getters and setters</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 94. Target object</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">Target</span> {

    <span class="directive">static</span> <span class="type">class</span> <span class="class">NestedTarget</span> {
        <span class="directive">private</span> <span class="predefined-type">String</span> property;
        <span class="comment">// getters and setters</span>
    }

    <span class="directive">private</span> NestedTarget nested;
    <span class="comment">// getters and setters</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 95. Mapper definition</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">ErroneousCustomExclusionMapper</span> {

    <span class="predefined-type">Target</span> map(<span class="predefined-type">Source</span> source);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We want to exclude the <code>NestedTarget</code> from the automatic sub-mapping method generation.</p>
</div>
<div class="exampleblock">
<div class="title">Example 96. CustomMappingExclusionProvider</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre>
<span class="keyword">import</span> <span class="include">java.util.regex.Pattern</span>;
<span class="keyword">import</span> <span class="include">javax.lang.model.element.Name</span>;
<span class="keyword">import</span> <span class="include">javax.lang.model.element.TypeElement</span>;

<span class="keyword">import</span> <span class="include">org.mapstruct.ap.spi.MappingExclusionProvider</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">CustomMappingExclusionProvider</span> <span class="directive">implements</span> MappingExclusionProvider {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Pattern</span> JAVA_JAVAX_PACKAGE = <span class="predefined-type">Pattern</span>.compile( <span class="string"><span class="delimiter">&quot;</span><span class="content">^javax?</span><span class="char">\\</span><span class="content">..*</span><span class="delimiter">&quot;</span></span> );

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> isExcluded(TypeElement typeElement) {
        <span class="predefined-type">Name</span> name = typeElement.getQualifiedName();
        <span class="keyword">return</span> name.length() != <span class="integer">0</span> &amp;&amp; ( JAVA_JAVAX_PACKAGE.matcher( name ).matches() ||
            name.toString().equals( <span class="string"><span class="delimiter">&quot;</span><span class="content">org.mapstruct.ap.test.nestedbeans.exclusions.custom.Target.NestedTarget</span><span class="delimiter">&quot;</span></span> ) );
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To use a custom SPI implementation, it must be located in a separate JAR file
together with the file <code>META-INF/services/org.mapstruct.ap.spi.MappingExclusionProvider</code> with the fully qualified name of your custom implementation as content
(e.g. <code>org.mapstruct.example.CustomMappingExclusionProvider</code>).
This JAR file needs to be added to the annotation processor classpath
(i.e. add it next to the place where you added the mapstruct-processor jar).</p>
</div>
</div>
<div class="sect2">
<h3 id="custom-builder-provider"><a class="anchor" href="#custom-builder-provider"></a>13.2. Custom Builder Provider</h3>
<div class="paragraph">
<p>MapStruct offers the possibility to override the <code>DefaultProvider</code> via the Service Provider Interface (SPI).
A nice example is to provide support for a custom builder strategy.</p>
</div>
<div class="exampleblock">
<div class="title">Example 97. Custom Builder Provider which disables Builder support</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre>
<span class="keyword">import</span> <span class="include">javax.lang.model.type.TypeMirror</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">NoOpBuilderProvider</span> <span class="directive">implements</span> BuilderProvider {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> BuilderInfo findBuilderInfo(TypeMirror type) {
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom-enum-naming-strategy"><a class="anchor" href="#custom-enum-naming-strategy"></a>13.3. Custom Enum Naming Strategy</h3>
<div class="paragraph">
<p>MapStruct offers the possibility to override the <code>EnumMappingStrategy</code> via the Service Provider Interface (SPI).
This can be used when you have certain enums that follow some conventions within your organization.
For example all enums which implement an interface named <code>CustomEnumMarker</code> are prefixed with <code>CUSTOM_</code>
and the default value for them when mapping from <code>null</code> is <code>UNSPECIFIED</code></p>
</div>
<div class="exampleblock">
<div class="title">Example 98. Normal Enum</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">enum</span> CheeseType {
    BRIE,
    ROQUEFORT;
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 99. Custom marker enum</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">enum</span> CustomCheeseType <span class="directive">implements</span> CustomEnumMarker {

    UNSPECIFIED,
    CUSTOM_BRIE,
    CUSTOM_ROQUEFORT;
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We want <code>CheeseType</code> and <code>CustomCheeseType</code> to be mapped without the need to manually define the value mappings:</p>
</div>
<div class="exampleblock">
<div class="title">Example 100. Custom enum mapping</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">CheeseTypeMapper</span> {

    CheeseType map(CustomCheeseType cheese);

    CustomCheeseType map(CheeseType cheese);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This can be achieved with implementing the SPI <code>org.mapstruct.ap.spi.EnumMappingStrategy</code> as in the following example.
Here’s an implemented <code>org.mapstruct.ap.spi.EnumMappingStrategy</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 101. Custom enum naming strategy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">CustomEnumMappingStrategy</span> <span class="directive">extends</span> DefaultEnumMappingStrategy {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getDefaultNullEnumConstant(TypeElement enumType) {
        <span class="keyword">if</span> ( isCustomEnum( enumType ) ) {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">UNSPECIFIED</span><span class="delimiter">&quot;</span></span>;
        }

        <span class="keyword">return</span> <span class="local-variable">super</span>.getDefaultNullEnumConstant( enumType );
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getEnumConstant(TypeElement enumType, <span class="predefined-type">String</span> enumConstant) {
        <span class="keyword">if</span> ( isCustomEnum( enumType ) ) {
            <span class="keyword">return</span> getCustomEnumConstant( enumConstant );
        }
        <span class="keyword">return</span> <span class="local-variable">super</span>.getEnumConstant( enumType, enumConstant );
    }
     <span class="directive">protected</span> <span class="predefined-type">String</span> getCustomEnumConstant(<span class="predefined-type">String</span> enumConstant) {
        <span class="keyword">if</span> ( <span class="string"><span class="delimiter">&quot;</span><span class="content">UNSPECIFIED</span><span class="delimiter">&quot;</span></span>.equals( enumConstant ) ) {
            <span class="keyword">return</span> MappingConstantsGem.NULL;
        }
         <span class="keyword">return</span> enumConstant.replace( <span class="string"><span class="delimiter">&quot;</span><span class="content">CUSTOM_</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> );
    }
     <span class="directive">protected</span> <span class="type">boolean</span> isCustomEnum(TypeElement enumType) {
        <span class="keyword">for</span> ( TypeMirror enumTypeInterface : enumType.getInterfaces() ) {
            <span class="keyword">if</span> ( typeUtils.asElement( enumTypeInterface ).getSimpleName().contentEquals( <span class="string"><span class="delimiter">&quot;</span><span class="content">CustomEnumMarker</span><span class="delimiter">&quot;</span></span> ) ) {
                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
            }
        }
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The generated code then for the <code>CheeseMapper</code> looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 102. Generated CheeseTypeMapper</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">CheeseTypeMapperImpl</span> <span class="directive">implements</span> CheeseTypeMapper {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> CheeseType map(CustomCheeseType cheese) {
        <span class="keyword">if</span> ( cheese == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }

        CheeseType cheeseType;

        <span class="keyword">switch</span> ( cheese ) {
            <span class="keyword">case</span> UNRECOGNIZED: cheeseType = <span class="predefined-constant">null</span>;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> CUSTOM_BRIE: cheeseType = CheeseType.BRIE;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> CUSTOM_ROQUEFORT: cheeseType = CheeseType.ROQUEFORT;
            <span class="keyword">break</span>;
            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>( <span class="string"><span class="delimiter">&quot;</span><span class="content">Unexpected enum constant: </span><span class="delimiter">&quot;</span></span> + cheese );
        }

        <span class="keyword">return</span> cheeseType;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> CustomCheeseType map(CheeseType cheese) {
        <span class="keyword">if</span> ( cheese == <span class="predefined-constant">null</span> ) {
            <span class="keyword">return</span> CustomCheeseType.UNSPECIFIED;
        }

        CustomCheeseType customCheeseType;

        <span class="keyword">switch</span> ( cheese ) {
            <span class="keyword">case</span> BRIE: customCheeseType = CustomCheeseType.CUSTOM_BRIE;
            <span class="keyword">break</span>;
            <span class="keyword">case</span> ROQUEFORT: customCheeseType = CustomCheeseType.CUSTOM_ROQUEFORT;
            <span class="keyword">break</span>;
            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>( <span class="string"><span class="delimiter">&quot;</span><span class="content">Unexpected enum constant: </span><span class="delimiter">&quot;</span></span> + cheese );
        }

        <span class="keyword">return</span> customCheeseType;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom-enum-transformation-strategy"><a class="anchor" href="#custom-enum-transformation-strategy"></a>13.4. Custom Enum Transformation Strategy</h3>
<div class="paragraph">
<p>MapStruct offers the possibility to other transformations strategies by implementing <code>EnumTransformationStrategy</code> via the Service Provider Interface (SPI).
A nice example is to provide support for a custom transformation strategy.</p>
</div>
<div class="exampleblock">
<div class="title">Example 103. Custom Enum Transformation Strategy which lower-cases the value and applies a suffix</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre>
<span class="keyword">import</span> <span class="include">org.mapstruct.ap.spi.EnumTransformationStrategy</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">CustomEnumTransformationStrategy</span> <span class="directive">implements</span> EnumTransformationStrategy {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getStrategyName() {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">custom</span><span class="delimiter">&quot;</span></span>;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> transform(<span class="predefined-type">String</span> value, <span class="predefined-type">String</span> configuration) {
        <span class="keyword">return</span> value.toLowerCase() + configuration;
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="third-party-api-integration"><a class="anchor" href="#third-party-api-integration"></a>14. Third-party API integration</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="non-shipped-annotations"><a class="anchor" href="#non-shipped-annotations"></a>14.1. Non-shipped annotations</h3>
<div class="paragraph">
<p>There are various use-cases you must resolve ambiguity for MapStruct to use a correct piece of code.
However, the primary goal of MapStruct is to focus on bean mapping without polluting the entity code.
For that reason, MapStruct is flexible enough to interact with already defined annotations from third-party libraries.
The requirement to enable this behavior is to match the <em>name</em> of such annotation.
Hence, we say that annotation can be <em>from any package</em>.</p>
</div>
<div class="paragraph">
<p>The annotations <em>named</em> <code>@ConstructorProperties</code> and <code>@Default</code> are currently examples of this kind of annotation.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If such named third-party annotation exists, it does not guarantee its <code>@Target</code> matches with the intended placement.
Be aware of placing a third-party annotation just for sake of mapping is not recommended as long as it might lead to unwanted side effects caused by that library.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A very common case is that no third-party dependency imported to your project provides such annotation or is inappropriate for use as already described.
In such cases create your own annotation, for example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre><span class="keyword">package</span> <span class="namespace">foo.support.mapstruct</span>;

<span class="keyword">import</span> <span class="include">java.lang.annotation.ElementType</span>;
<span class="keyword">import</span> <span class="include">java.lang.annotation.Retention</span>;
<span class="keyword">import</span> <span class="include">java.lang.annotation.RetentionPolicy</span>;
<span class="keyword">import</span> <span class="include">java.lang.annotation.Target</span>;

<span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.CONSTRUCTOR)
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.CLASS)
<span class="directive">public</span> <span class="annotation">@interface</span> Default {

}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="lombok"><a class="anchor" href="#lombok"></a>14.2. Lombok</h3>
<div class="paragraph">
<p>MapStruct works together with <a href="https://projectlombok.org/">Project Lombok</a> as of MapStruct 1.2.0.Beta1 and Lombok 1.16.14.</p>
</div>
<div class="paragraph">
<p>MapStruct takes advantage of generated getters, setters, and constructors and uses them to generate the mapper implementations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Lombok 1.18.16 introduces a breaking change (<a href="https://projectlombok.org/changelog">changelog</a>).
The additional annotation processor <code>lombok-mapstruct-binding</code> (<a href="https://mvnrepository.com/artifact/org.projectlombok/lombok-mapstruct-binding">Maven</a>) must be added otherwise MapStruct stops working with Lombok.
This resolves the compilation issues of Lombok and MapStruct modules.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;path&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.projectlombok<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>lombok-mapstruct-binding<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>0.1.0<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/path&gt;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_set_up"><a class="anchor" href="#_set_up"></a>14.2.1. Set up</h4>
<div class="paragraph">
<p>The set up using Maven or Gradle does not differ from what is described in <a href="#setup">Set up</a>. Additionally, you need to provide Lombok dependencies.</p>
</div>
<div class="exampleblock">
<div class="title">Example 104. Maven configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td>
  <td class="code"><pre>
<span class="tag">&lt;properties&gt;</span>
    <span class="tag">&lt;org.mapstruct.version&gt;</span>1.4.2.Final<span class="tag">&lt;/org.mapstruct.version&gt;</span>
    <span class="tag">&lt;org.projectlombok.version&gt;</span>1.18.16<span class="tag">&lt;/org.projectlombok.version&gt;</span>
    <span class="tag">&lt;maven.compiler.source&gt;</span>1.8<span class="tag">&lt;/maven.compiler.source&gt;</span>
    <span class="tag">&lt;maven.compiler.target&gt;</span>1.8<span class="tag">&lt;/maven.compiler.target&gt;</span>
<span class="tag">&lt;/properties&gt;</span>

<span class="tag">&lt;dependencies&gt;</span>
    <span class="tag">&lt;dependency&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>org.mapstruct<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>mapstruct<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;version&gt;</span>${org.mapstruct.version}<span class="tag">&lt;/version&gt;</span>
    <span class="tag">&lt;/dependency&gt;</span>

    <span class="comment">&lt;!-- lombok dependency should not end up on classpath --&gt;</span>
    <span class="tag">&lt;dependency&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>org.projectlombok<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>lombok<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;version&gt;</span>${org.projectlombok.version}<span class="tag">&lt;/version&gt;</span>
        <span class="tag">&lt;scope&gt;</span>provided<span class="tag">&lt;/scope&gt;</span>
    <span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;/dependencies&gt;</span>

<span class="tag">&lt;build&gt;</span>
    <span class="tag">&lt;plugins&gt;</span>
        <span class="tag">&lt;plugin&gt;</span>
            <span class="tag">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/groupId&gt;</span>
            <span class="tag">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="tag">&lt;/artifactId&gt;</span>
            <span class="tag">&lt;version&gt;</span>3.8.1<span class="tag">&lt;/version&gt;</span>
            <span class="tag">&lt;configuration&gt;</span>
                <span class="tag">&lt;source&gt;</span>1.8<span class="tag">&lt;/source&gt;</span>
                <span class="tag">&lt;target&gt;</span>1.8<span class="tag">&lt;/target&gt;</span>
                <span class="tag">&lt;annotationProcessorPaths&gt;</span>
                    <span class="tag">&lt;path&gt;</span>
                        <span class="tag">&lt;groupId&gt;</span>org.mapstruct<span class="tag">&lt;/groupId&gt;</span>
                        <span class="tag">&lt;artifactId&gt;</span>mapstruct-processor<span class="tag">&lt;/artifactId&gt;</span>
                        <span class="tag">&lt;version&gt;</span>${org.mapstruct.version}<span class="tag">&lt;/version&gt;</span>
                    <span class="tag">&lt;/path&gt;</span>
                    <span class="tag">&lt;path&gt;</span>
                        <span class="tag">&lt;groupId&gt;</span>org.projectlombok<span class="tag">&lt;/groupId&gt;</span>
                        <span class="tag">&lt;artifactId&gt;</span>lombok<span class="tag">&lt;/artifactId&gt;</span>
                        <span class="tag">&lt;version&gt;</span>${org.projectlombok.version}<span class="tag">&lt;/version&gt;</span>
                    <span class="tag">&lt;/path&gt;</span>

                    <span class="comment">&lt;!-- additional annotation processor required as of Lombok 1.18.16 --&gt;</span>
                    <span class="tag">&lt;path&gt;</span>
                        <span class="tag">&lt;groupId&gt;</span>org.projectlombok<span class="tag">&lt;/groupId&gt;</span>
                        <span class="tag">&lt;artifactId&gt;</span>lombok-mapstruct-binding<span class="tag">&lt;/artifactId&gt;</span>
                        <span class="tag">&lt;version&gt;</span>0.1.0<span class="tag">&lt;/version&gt;</span>
                    <span class="tag">&lt;/path&gt;</span>
                <span class="tag">&lt;/annotationProcessorPaths&gt;</span>
            <span class="tag">&lt;/configuration&gt;</span>
        <span class="tag">&lt;/plugin&gt;</span>
    <span class="tag">&lt;/plugins&gt;</span>
<span class="tag">&lt;/build&gt;</span></pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 105. Gradle configuration (3.4 and later)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>
dependencies {

    implementation <span class="string"><span class="delimiter">&quot;</span><span class="content">org.mapstruct:mapstruct:</span><span class="inline"><span class="inline-delimiter">${</span>mapstructVersion<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    implementation <span class="string"><span class="delimiter">&quot;</span><span class="content">org.projectlombok:lombok:1.18.16</span><span class="delimiter">&quot;</span></span>
    annotationProcessor <span class="string"><span class="delimiter">&quot;</span><span class="content">org.projectlombok:lombok-mapstruct-binding:0.1.0</span><span class="delimiter">&quot;</span></span>
    annotationProcessor <span class="string"><span class="delimiter">&quot;</span><span class="content">org.mapstruct:mapstruct-processor:</span><span class="inline"><span class="inline-delimiter">${</span>mapstructVersion<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    annotationProcessor <span class="string"><span class="delimiter">&quot;</span><span class="content">org.projectlombok:lombok:1.18.16</span><span class="delimiter">&quot;</span></span>
}
</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The usage combines what you already know from <a href="#defining-mapper">Defining a mapper</a> and Lombok.</p>
</div>
<div class="exampleblock">
<div class="title">Example 106. Usage of MapStruct with Lombok</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre><span class="annotation">@Data</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Source</span> {

    <span class="directive">private</span> <span class="predefined-type">String</span> test;
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Target</span> {

    <span class="directive">private</span> <span class="predefined-type">Long</span> testing;

    <span class="directive">public</span> <span class="predefined-type">Long</span> getTesting() {
        <span class="keyword">return</span> testing;
    }

    <span class="directive">public</span> <span class="type">void</span> setTesting( <span class="predefined-type">Long</span> testing ) {
        <span class="local-variable">this</span>.testing = testing;
    }
}

<span class="annotation">@Mapper</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">SourceTargetMapper</span> {

    SourceTargetMapper MAPPER = Mappers.getMapper( SourceTargetMapper.class );

    <span class="annotation">@Mapping</span>( source = <span class="string"><span class="delimiter">&quot;</span><span class="content">test</span><span class="delimiter">&quot;</span></span>, target = <span class="string"><span class="delimiter">&quot;</span><span class="content">testing</span><span class="delimiter">&quot;</span></span> )
    <span class="predefined-type">Target</span> toTarget( <span class="predefined-type">Source</span> s );
}
</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A working example can be found on the GitHub project <a href="https://github.com/mapstruct/mapstruct-examples/tree/master/mapstruct-lombok">mapstruct-lombok</a>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-01-31 13:49:16 +0100
</div>
</div>
</body>
</html>