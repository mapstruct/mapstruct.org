---
layout: base
---
.row
  .span12
    %h2 MapStruct User Guide

.row
  .span9
    .row
      .span9
        :markdown
          This is the MapStruct reference documentation which covers all functionality provided by MapStruct. In case this guide doesn't answer all your questions just join the MapStruct [Google group](https://groups.google.com/forum/?fromgroups#!forum/mapstruct-users) to get help.

          You found a typo or other error in this guide? Your pull request against this web site's [GitHub repository](http://github.com/mapstruct/mapstruct.org) is more than welcome!

    .row
      .span9
        %h3#section-01 1. Introduction
        :markdown
          MapStruct is a Java [annotation processor](http://docs.oracle.com/javase/6/docs/technotes/guides/apt/index.html) for the generation of type-safe bean mapping classes.

          All you have to do is to define a mapper interface which declares any required mapping methods. During compilation, MapStruct will generate an implementation of this interface. This implementation uses plain Java method invocations for mapping between source and target objects, i.e. no reflection or similar.

          Compared to writing mapping code from hand, MapStruct saves time by generating code which is tedious and error-prone to write. Following a convention over configuration approach, MapStruct uses sensible defaults but steps out of your way when it comes to configuring or implementing special behavior.

          Compared to dynamic mapping frameworks, MapStruct offers the following advantages:

          * Fast execution by using plain method invocations instead of reflection
          * Compile-time type safety: Only objects and attributes mapping to each other can be mapped, no accidental mapping of an order entity into a customer DTO etc.
          * Clear error-reports at build time, if entities or attributes can't be mapped

    .row
      .span9
        %h3#section-02 2. Set up

        :markdown
          MapStruct is a Java annotation processor based on [JSR 269](jcp.org/en/jsr/detail?id=269) and as such can be used within command line builds (javac, Ant, Maven etc.) as well as from within your IDE.

          It comprises the following artifacts:

          * _org.mapstruct:mapstruct_: contains the required annotations such as `@Mapping`; On Java 8 or later, use _org.mapstruct:mapstruct-jdk8_ instead which takes advantage of language improvements introduced in Java 8
          * _org.mapstruct:mapstruct-processor_: contains the annotation processor which generates mapper implementations

          For Maven based projects add the following to your POM file in order to use MapStruct:

        %pre.prettyprint.lang-xml.linenums
          = preserve do
            :escaped
              ...
              <properties>
                  <org.mapstruct.version>1.0.0.Beta3</org.mapstruct.version>
              </properties>
              ...
              <dependencies>
                  <dependency>
                      <groupId>org.mapstruct</groupId>
                      <artifactId>mapstruct-jdk8</artifactId>
                      <version>${org.mapstruct.version}</version>
                  </dependency>
              </dependencies>
              ...
              <build>
                  <plugins>
                      <plugin>
                          <groupId>org.bsc.maven</groupId>
                          <artifactId>maven-processor-plugin</artifactId>
                          <version>2.2.4</version>
                          <configuration>
                              <defaultOutputDirectory>
                                  ${project.build.directory}/generated-sources
                              </defaultOutputDirectory>
                              <processors>
                                  <processor>org.mapstruct.ap.MappingProcessor</processor>
                              </processors>
                          </configuration>
                          <executions>
                              <execution>
                                  <id>process</id>
                                  <phase>generate-sources</phase>
                                  <goals>
                                      <goal>process</goal>
                                  </goals>
                              </execution>
                          </executions>
                          <dependencies>
                              <dependency>
                                  <groupId>org.mapstruct</groupId>
                                  <artifactId>mapstruct-processor</artifactId>
                                  <version>${org.mapstruct.version}</version>
                              </dependency>
                          </dependencies>
                      </plugin>
                  </plugins>
              </build>

        %h4#section-02-01 2.1 Configuration options

        :markdown
          The MapStruct code generator can be configured using _annotation processor options_.

          When invoking javac directly, these options are passed to the compiler in the form _-Akey=value_. When using MapStruct via Maven, any processor options can be passed using an `options` element within the configuration of the Maven processor plug-in like this:

        %pre.prettyprint.lang-xml.linenums
          = preserve do
            :escaped
              ...
              <plugin>
                  <groupId>org.bsc.maven</groupId>
                  <artifactId>maven-processor-plugin</artifactId>
                  <configuration>
                      <processors>
                          <processor>org.mapstruct.ap.MappingProcessor</processor>
                      </processors>
                      <options>
                          <mapstruct.suppressGeneratorTimestamp>true</mapstruct.suppressGeneratorTimestamp>
                          <mapstruct.defaultComponentModel>cdi</mapstruct.defaultComponentModel>
                      </options>
                      ...
                  </configuration>
                  ...
              <plugin>
              ...

        :markdown
          The following options exist:

        %table.table
          %thead
            %tr
              %th Option
              %th Purpose
              %th Default
          %tbody
            %tr
              %td mapstruct.suppressGeneratorTimestamp
              %td Whether the creation of a time stamp in the generated mapper classes is suppressed or not
              %td
                :markdown
                  `false`
            %tr
              %td mapstruct.defaultComponentModel
              %td
                :markdown
                  The name of the component model (see [section 4.2](#section-04-2)) based on which mappers should be generated. Supported values are:

                %ul
                  %li
                    :markdown
                      `default`: the mapper uses no component model, instances are typically retrieved via `Mappers#getMapper(Class)`
                  %li
                    :markdown
                      `cdi`: the generated mapper is an application-scoped CDI bean and can be retrieved via `@Inject`
                  %li
                    :markdown
                      `spring`: the generated mapper is a singleton-scoped Spring bean and can be retrieved via `@Autowired`
                  %li
                    :markdown
                      `jsr330`: the generated mapper is annotated with {@code @Named} and can be retrieved via `@Inject`, e.g. using Spring

                :markdown
                  If a component model is given for a specific mapper via `@Mapper#componentModel()`, the value from the annotation takes precedence.
              %td
                :markdown
                  `default`

            %tr
              %td mapstruct.unmappedTargetPolicy
              %td
                :markdown
                  The default reporting policy to be applied in case an attribute of the target object of a mapping method is not populated with a source value.
                  Supported values are:

                %ul
                  %li
                    :markdown
                      `ERROR`: any unmapped target property will cause the mapping code generation to fail
                  %li
                    :markdown
                      `WARN`: any unmapped target property will cause a warning at build time
                  %li
                    :markdown
                      `IGNORE`: unmapped target properties are ignored

                :markdown
                  If a policy is given for a specific mapper via `@Mapper#unmappedTargetPolicy()`, the value from the annotation takes precedence.
              %td
                :markdown
                  `WARN`

    .row
      .span9
        %h3#section-03 3. Defining a mapper
        :markdown
          In this section you'll learn how to define a bean mapper with MapStruct and which options you have to do so.

        %h4#section-03-01 3.1 Basic mappings
        :markdown
          To create a mapper simply define a Java interface with the required mapping method(s) and annotate it with the `org.mapstruct.Mapper` annotation:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public interface CarMapper {

                  @Mappings({
                      @Mapping(source = "make", target = "manufacturer"),
                      @Mapping(source = "numberOfSeats", target = "seatCount")
                  })
                  CarDto carToCarDto(Car car);

                  @Mapping(source = "name", target = "fullName")
                  PersonDto personToPersonDto(Person person);
              }

        :markdown
          The `@Mapper` annotation causes the MapStruct code generator to create an implementation of the `CarMapper` interface during build-time.

          In the generated method implementations all readable properties from the source type (e.g. `Car`) will be copied ino the corresponding property in the target type (e.g. `CarDto`). If a property has a different name in the target entity, its name can be specified via the `@Mapping` annotation.

        .alert.alert-info
          :markdown
            **Tip!** The property name as defined in the [JavaBeans spefication](http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html) must be specified in the `@Mapping` annotation, e.g. _seatCount_ for a property with the accessor methods `getSeatCount()` and `setSeatCount()`.

        .alert.alert-info
          :markdown
            **Tip!** When using Java 8 or later, you can omit the `@Mappings` wrapper annotation and directly specify several `@Mapping` annotations on one method.

        :markdown
          To get a better understanding of what MapStruct does have a look at the following implementation of the `carToCarDto()` method as generated by MapStruct:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              // GENERATED CODE
              public class CarMapperImpl implements CarMapper {

                  @Override
                  public CarDto carToCarDto(Car car) {
                      if ( car == null ) {
                          return null;
                      }

                      CarDto carDto = new CarDto();

                      if ( car.getFeatures() != null ) {
                          carDto.setFeatures( new ArrayList<String>( car.getFeatures() ) );
                      }
                      carDto.setManufacturer( car.getMake() );
                      carDto.setSeatCount( car.getNumberOfSeats() );
                      carDto.setDriver( personToPersonDto( car.getDriver() ) );
                      carDto.setPrice( String.valueOf( car.getPrice() ) );
                      if ( car.getCategory() != null ) {
                          carDto.setCategory( car.getCategory().toString() );
                      }

                      return carDto;
                  }

                  @Override
                  public PersonDto personToPersonDto(Person person) {
                      //...
                  }
              }

        :markdown
          The general philosophy of MapStruct is to generate code which looks as much as possible as if you had written it yourself from hand. In particular this means that the values are copied from source to target by plain getter/setter invocations instead of reflection or similar.

          As the example shows the generated code takes into account any name mappings specified via `@Mapping`. If the type of a mapped attribute is different in source and target entity, MapStruct will either apply an automatic conversion (as e.g. for the _price_ property, see also [Implicit type conversions](#section-05-01)) or optionally invoke another mapping method (as e.g. for the _driver_ property, see also [Mapping object references](#section-05-02)).

          Collection-typed attributes with the same element type will be copied by creating a new instance of the target collection type containing the elements from the source property. For collection-typed attributes with different element types each element will mapped individually and added to the target collection (see [Mapping collections](#section-06)).

          MapStruct takes all public properties of the source and target types into account. This includes properties declared on super-types.

        %h4#section-03-02 3.2 Generating mappers from abstract classes
        :markdown
          In some cases it can be required to manually implement a specific mapping from one type to another which can't be generated by MapStruct. One way for this is to implement such method on another class which then is used by mappers generated by MapStruct (see [Invoking other mappers](#section-05-03)).

          Alternatively you can define a mapper in form of an abstract class instead of an interface and implement custom methods directly in this mapper class. In this case MapStruct will generate an extension of the abstract class with implementations of all abstract methods.

          As an example let's assume the mapping from `Person` to `PersonDto` requires some special logic which can't be generated by MapStruct. You could then define the mapper from the previous example like this:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public abstract class CarMapper {

                  @Mappings(...)
                  public abstract CarDto carToCarDto(Car car);

                  public PersonDto personToPersonDto(Person person) {
                      //hand-written mapping logic
                  }
              }

        :markdown
          MapStruct will generate a sub-class of `CarMapper` with an implementation of the `carToCarDto()` method as it is declared abstract. The generated code in `carToCarDto()` will invoke the manually implemented `personToPersonDto()` method when mapping the `driver` attribute.

        %h4#section-03-03 3.3 Mapping methods with several source parameters
        :markdown
          MapStruct also supports mapping methods with several source parameters. This is useful e.g. in order to combine several entities into one data transfer object. The following shows an example:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public interface AddressMapper {

                  @Mappings({
                      @Mapping(source = "person.description", target = "description"),
                      @Mapping(source = "address.houseNo", target = "houseNumber")
                  })
                  DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);
              }

        :markdown
          The shown mapping method takes two source parameters and returns a combined target object. As with single-parameter mapping methods properties are mapped by name.

          In case several source objects define a property with the same name, the source parameter from which to retrieve the property must be specified using the `@Mapping` annotation as shown for the `description` property in the example. An error will be raised when such an ambiguity is not resolved. For properties which only exist once in the given source objects it is optional to specify the source parameter's name as it can be determined automatically.

        .alert.alert-warn
          :markdown
            **Note!** Specifying the parameter in which the property resides is mandatory when using the `@Mapping` annotation.
          
          
        .alert.alert-info
          :markdown
            **Tip!** Mapping methods with several source parameters will return `null` in case all the source parameters are `null`. Otherwise the target object will be instantiated and all properties from the provided parameters will be propagated.

        %h4#section-03-04 3.4 Nested mappings
        :markdown
          MapStruct will handle nested mappings, by means of the `.` notation:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mappings({
                  @Mapping(target = "chartName", source = "chart.name"),
                  @Mapping(target = "title", source = "song.title"),
                  @Mapping(target = "artistName", source = "song.artist.name"),
                  @Mapping(target = "recordedAt", source = "song.artist.label.studio.name"),
                  @Mapping(target = "city", source = "song.artist.label.studio.city"),
                  @Mapping(target = "position", source = "position")
              })
              ChartEntry map(Chart chart, Song song, Integer position);
 
        :markdown
          Note: the parameter name (`chart`, `song`, `position`) is required, since there are several source parameters in the mapping. If there's only one source parameter, the parameter name can be ommited.
          
          MapStruct will perform a null check on each nested property in the source.
                    
        .alert.alert-info
          :markdown
            **Tip!** Also non java bean source parameters (like the `java.lang.Integer`) can be mapped in this fashion.


        %h4#section-03-05 3.5 Updating existing bean instances
        :markdown
          In some cases you need mappings which don't create a new instance of the target type but instead update an existing instance of that type. This sort of mapping can be realized by adding a parameter for the target object and marking this parameter with `@MappingTarget`. The following shows an example:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public interface CarMapper {

                  void updateCarFromDto(CarDto carDto, @MappingTarget Car car);
              }

        :markdown
          The generated code of the `updateCarFromDto()` method will upate the passed `Car` instance with the properties from the given `CarDto` object. There may be only one parameter marked as mapping target. Instead of `void` you may also set the method's return type to the type of the target parameter, which will cause the generated implementation to update the passed mapping target and return it as well. This allows for fluent invocations of mapping methods.

          Collection- or map-typed properties of the target bean to be updated will be cleared and then populated with the values from the corresponding source collection or map.

    .row
      .span9
        %h3#section-04 4. Retrieving a mapper
        %h4#section-04-01 4.1 The Mappers factory

        :markdown
          Mapper instances can be retrieved via the `org.mapstruct.factory.Mappers` class. Just invoke the `getMapper()` method, passing the interface type of the mapper to return:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              CarMapper mapper = Mappers.getMapper( CarMapper.class );

        :markdown
           By convention, a mapper interface should define a member called `INSTANCE` which holds a single instance of the mapper type:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public interface CarMapper {

                  CarMapper INSTANCE = Mappers.getMapper( CarMapper.class );

                  CarDto carToCarDto(Car car);
              }

        :markdown
          This pattern makes it very easy for clients to use mapper objects without repeatedly instantiating new instances:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              Car car = ...;
              CarDto dto = CarMapper.INSTANCE.carToCarDto( car );

        :markdown
          Note that mappers generated by MapStruct are thread-safe and thus can safely be accessed from several threads at the same time.

        %h4#section-04-02 4.2 Using dependency injection

        :markdown
          If you're working with a dependency injection framework such as [CDI](http://jcp.org/en/jsr/detail?id=346) (Contexts and Dependency Injection for Java<sup>TM</sup> EE) or the [Spring Framework](http://www.springsource.org/spring-framework), it is recommended to obtain mapper objects via dependency injection as well. For that purpose you can specify the component model which generated mapper classes should be based on either via `@Mapper#componentModel` or using a processor option as described in [section](section-02-01).

          Currently there is support for CDI and Spring (the later either via its custom annotations or using the JSR 330 annotations). See [section](section-02-01) for the allowed values of the `componentModel` attribute which are the same as for the `mapstruct.defaultComponentModel` processor option. In both cases the required annotations will be added to the generated mapper implementations classes in order to make the same subject to dependency injection. The following shows an example using CDI:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper(componentModel = "cdi")
              public interface CarMapper {

                  CarDto carToCarDto(Car car);
              }

        :markdown
          The generated mapper implementation will be marked with the `@ApplicationScoped` annotation and thus can be injected into fields, constructor arguments etc. using the `@Inject` annotation:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Inject
              private CarMapper mapper;

        :markdown
          A mapper which uses other mapper classes (see [section](section-05-03)) will obtain these mappers using the configured component model. So if `CarMapper` from the previous example was using another mapper, this other mapper would have to be an injectable CDI bean as well.

    .row
      .span9
        %h3#section-05 5. Data type conversions
        :markdown
          Not always a mapped attribute has the same type in the source and target objects. For instance an attribute may be of type `int` in the source bean but of type `Long` in the target bean.

          Another example are references to other objects which should be mapped to the corresponding types in the target model. E.g. the class `Car` might have a property `driver` of the type `Person` which needs to be converted into a `PersonDto` object when mapping a `Car` object.

          In this section you'll learn how MapStruct deals with such data type conversions.

        %h4#section-05-01 5.1 Implicit type conversions

        :markdown
          MapStruct takes care of type conversions automatically in many cases. If for instance an attribute is of type `int` in the source bean but of type `String` in the target bean, the generated code will transparently perform a conversion by calling `String#valueOf(int)` and `Integer#parseInt(String)`, respectively.

          Currently the following conversions are applied automatically:

          * Between all Java primitive data types and their corresponding wrapper types, e.g. between `int` and `Integer`, `boolean` and `Boolean` etc. The generated code is `null` aware, i.e. when converting a wrapper type into the corresponding primitive type a `null` check will performed.

          * Between all Java primitive number types and the wrapper types, e.g. between `int` and `long` or `byte` and `Integer`.

        .alert.alert-warn
          :markdown
            **Note!** Converting from larger data types to smaller ones (e.g. from `long` to `int`) can cause a value or precision loss. There [will be](https://github.com/mapstruct/mapstruct/issues/5) an option for raising a warning in such cases in a future MapStruct version.

        :markdown
          * Between all Java primitive types (including their wrappers) and `String`, e.g. between `int` and `String` or `Boolean` and `String`.

          * Between `enum` types and `String`.

          * Between big number types (`java.math.BigInteger`, `java.math.BigDecimal`) and Java primitive types (including their wrappers) as well as String

          * Between `JAXBElement<T>` and `T`, `List<JAXBElement<T>>` and `List<T>`

          * Between `java.util.Calendar`/`java.util.Date` and JAXB's `XMLGregorianCalendar`

          * Between `java.util.Date`/`XMLGregorianCalendar` and `String`. A format string as understood by `java.text.SimpleDateFormat` can be specified via the `dateFormat` option as this:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public interface CarMapper {

                @Mapping(source = "manufacturingDate", dateFormat = "dd.MM.yyyy")
                CarDto carToCarDto(Car car);

                @IterableMapping(dateFormat = "dd.MM.yyyy")
                List<String> stringListToDateList(List<Date> dates);
              }

        :markdown
          * Between Jodas `org.joda.time.DateTime`, `org.joda.time.LocalDateTime`, `org.joda.time.LocalDate`, `org.joda.time.LocalTime` and `String`. A format string as understood by `java.text.SimpleDateFormat` can be specified via the `dateFormat` option (see above).

          * Between Jodas `org.joda.time.DateTime` and `java.util.Calendar`.

          * Between Jodas `org.joda.time.LocalDateTime`, `org.joda.time.LocalDate` and `java.util.Date`.

          * Between `java.time.ZonedDateTime`, `java.time.LocalDateTime`, `java.time.LocalDate`, `java.time.LocalTime` from Java 8 Date-Time package and `String`. A format string as understood by `java.text.SimpleDateFormat` can be specified via the `dateFormat` option (see above).

          * Between `java.time.ZonedDateTime` from Java 8 Date-Time package and `java.util.Date` where, when mapping a `ZonedDateTime` from a given `Date`, systems default timezone is used. 

          * Between `java.time.LocalDateTime` from Java 8 Date-Time package and `java.util.Date` where. When converting a `LocalDateTime` from a given `Date`, systems default timezone is used. When mapping a `Date` to a `LocalDateTime` UTC is used as the timzone.

          * Between `java.time.ZonedDateTime` from Java 8 Date-Time package and `java.util.Calendar`. 

        %h4#section-05-02 5.2 Mapping object references

        :markdown
          Typically an object has not only primitive attributes but also references other objects. E.g. the `Car` class could contain a reference to a `Person` object (representing the car's driver) which should be mapped to a `PersonDto` object referenced by the `CarDto` class.

          In this case just define a mapping method for the referenced object type as well:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public interface CarMapper {

                  CarDto carToCarDto(Car car);

                  PersonDto personToPersonDto(Person person);
              }

        :markdown
          The generated code for the `carToCarDto()` method will invoke the `personToPersonDto()` method for mapping the `driver` attribute, while the generated implementation for `personToPersonDto()` performs the mapping of person objects.

          That way it is possible to map arbitrary deep object graphs. When mapping from entities into data transfer objects it is often useful to cut references to other entities at a certain point. To do so, implement a custom mapping method (see the next section) which e.g. maps a referenced entity to its id in the target object.

        :markdown
          When generating the implementation of a mapping method, MapStruct will apply the following routine for each attribute pair in the source and target object:

          * If source and target attribute have the same type, the value will be simply copied from source to target. If the attribute is a collection (e.g. a `List`) a copy of the collection will be set into the target attribute.
          * If source and target attribute type differ, check whether there is a another mapping method which has the type of the source attribute as parameter type and the type of the target attribute as return type. If such a method exists it will be invoked in the generated mapping implementation.
          * If no such method exists MapStruct will look whether a built-in conversion for the source and target type of the attribute exists. If this is the case, the generated mapping code will apply this conversion.
          * Otherwise an error will be raised at build time, indicating the non-mappable attribute.

        %h4#section-05-03 5.3 Invoking other mappers

        :markdown
          In addition to methods defined on the same mapper type MapStruct can also invoke mapping methods defined in other classes, be it mappers generated by MapStruct or hand-written mapping methods. This can be useful to structure your mapping code in several classes (e.g. with on mapper type per application module) or you want to provide custom mapping logic which can't be generated by MapStruct.

          For instance the `Car` class might contain an attribute `manufacturingDate` while the corresponding DTO attribute is of type String. In order to map this attribute, you could implement a mapper class like this:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              public class DateMapper {

                  public String asString(Date date) {
                      return date != null ? new SimpleDateFormat( "yyyy-MM-dd" )
                          .format( date ) : null;
                  }

                  public Date asDate(String date) {
                      try {
                          return date != null ? new SimpleDateFormat( "yyyy-MM-dd" )
                              .parse( date ) : null;
                      }
                      catch ( ParseException e ) {
                          throw new RuntimeException( e );
                      }
                  }
              }

        :markdown
          In the `@Mapper` annotation at the `CarMapper` interface reference the `DateMapper` class like this:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper(uses=DateMapper.class)
              public class CarMapper {

                  CarDto carToCarDto(Car car);
              }
        :markdown
          When generating code for the implementation of the `carToCarDto()` method, MapStruct will look for a method which maps a `Date` object into a String, find it on the `DateMapper` class and generate an invocation of `asString()` for mapping the `manufacturingDate` attribute.

          Generated mappers retrieve referenced mappers using the component model configured for them. If e.g. CDI was used as component model for `CarMapper`, `DateMapper` would have to be a CDI bean as well. When using the default component model, any hand-written mapper classes to be referenced by MapStruct generated mappers must declare a public no-args constructor in order to be instantiable.

        %h4#section-05-04 5.4 Passing the mapping target type to custom mappers

        :markdown
          When having a custom mapper hooked into the generated mapper with `@Mapper#uses()`, an additional parameter of type `Class` (or a super-type of it) can be defined in the custom mapping method in order to perform general mapping tasks for specific target object types. That attribute must be annotated with `@TargetType` for MapStruct to generate calls that pass the `Class` instance representing the corresponding property type of the target bean.

          For instance, the `CarDto` could have a property `owner` of type `Reference` that contains the primary key of a `Person` entity. You could now create a generic custom mapper that resolves any `Reference` objects to their corresponding managed JPA entity instances.

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @ApplicationScoped // CDI component model
              public class ReferenceMapper {

                  @PersistenceContext
                  private EntityManager entityManager;

                  public <T extends BaseEntity> T resolve(Reference reference, @TargetType Class<T> entityClass) {
                      return reference != null ? entityManager.find( entityClass, reference.getPk() ) : null;
                  }

                  public Reference toReference(BaseEntity entity) {
                      return entity != null ? new Reference( entity.getPk() ) : null;
                  }
              }

              @Mapper(componentModel = "cdi", uses = ReferenceMapper.class )
              public interface CarMapper {

                  Car carDtoToCar(CarDto carDto);
              }

        :markdown
          MapStruct will then generate something like this:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              //GENERATED CODE
              @ApplicationScoped
              public class CarMapperImpl implements CarMapper {

                  @Inject
                  private ReferenceMapper referenceMapper;

                  @Override
                  public Car carDtoToCar(CarDto carDto) {
                      if ( carDto == null ) {
                          return null;
                      }

                      Car car = new Car();

                      car.setOwner( referenceMapper.resolve( carDto.getOwner(), Owner.class ) );
                      // ...

                      return car;
                  }
              }

        %h4#section-05-05 5.5 Mapping method resolution

        :markdown
          When mapping a property from one type to another, MapStruct looks for the most specific method which maps the source type into the target type. The method may either be declared on the same mapper interface or on another mapper which is registered via `@Mapper#uses()`. The same applies for factory methods (see [section 8](#section-08)).

          The algorithm for finding a mapping or factory method resembles Java's method resolution algorithm as much as possible. In particular, methods with a more specific source type will take precedence (e.g. if there are two methods, one which maps the searched source type, and another one which maps a super-type of the same). In case more than one most-specific method is found, an error will be raised.

        .alert.alert-info
          :markdown
            **Tip!** When working with JAXB, e.g. when converting a `String` to a corresponding `JAXBElement<String>`, MapStruct will take the `scope` and `name` attributes of `@XmlElementDecl` annotations into account when looking for a mapping method. This makes sure that the created `JAXBElement` instances will have the right QNAME value. You can find a test which maps JAXB objects [here](https://github.com/mapstruct/mapstruct/blob/1.0.0.Beta1/integrationtest/src/test/java/org/mapstruct/itest/jaxb/JaxbBasedMapperTest.java).

    .row
      .span9
        %h3#section-06 6. Mapping collections

        :markdown
          The mapping of collection types (`List`, `Set` etc.) is done in the same way as mapping bean types, i.e. by defining mapping methods with the required source and target types in a mapper interface. MapStruct supports a wide range of iterable types from the [Java Collection Framework](http://docs.oracle.com/javase/tutorial/collections/intro/index.html).

          The generated code will contain a loop which iterates over the source collection, converts each element and puts it into the target collection. If a mapping method for the collection element types is found in the given mapper or the mapper it uses, this method is invoked to perform the element conversion. Alternatively, if an implicit conversion for the source and target element types exists, this conversion routine will be invoked. The following shows an example:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public interface CarMapper {

                  Set<String> integerSetToStringSet(Set<Integer> integers);

                  List<CarDto> carsToCarDtos(List<Car> cars);

                  CarDto carToCarDto(Car car);
              }

        :markdown
          The generated implementation of the `integerSetToStringSet` performs the conversion from `Integer` to `String` for each element, while the generated `carsToCarDtos()` method invokes the `carToCarDto()` method for each contained element as shown in the following:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              //GENERATED CODE
              @Override
              public Set<String> integerSetToStringSet(Set<Integer> integers) {
                  if ( integers == null ) {
                      return null;
                  }

                  Set<String> set = new HashSet<String>();

                  for ( Integer integer : integers ) {
                      set.add( String.valueOf( integer ) );
                  }

                  return set;
              }

              @Override
              public List<CarDto> carsToCarDtos(List<Car> cars) {
                  if ( cars == null ) {
                      return null;
                  }

                  List<CarDto> list = new ArrayList<CarDto>();

                  for ( Car car : cars ) {
                      list.add( carToCarDto( car ) );
                  }

                  return list;
              }

        :markdown
          Note that MapStruct will look for a collection mapping method with matching parameter and return type, when mapping a collection-typed attribute of a bean, e.g. from `Car#passengers` (of type `List<Person>`) to `CarDto#passengers` (of type `List<PersonDto>`).

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              //GENERATED CODE
              carDto.setPassengers( personsToPersonDtos( car.getPassengers() ) );
              ...

        :markdown
          Some frameworks and libraries only expose JavaBeans getters but no setters for collection-typed properties. Types generated from an XML schema using JAXB adhere to this pattern by default. In this case the generated code for mapping such a property invokes its getter and adds all the mapped elements:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              //GENERATED CODE
              carDto.getPassengers().addAll( personsToPersonDtos( car.getPassengers() ) );
              ...

        .alert.alert-warn
          :markdown
            **Note!** It is not allowed to declare mapping methods with an iterable source and a non-iterable target or the other way around. An error will be raised when detecting this situation.

        %h4#section-06-01 6.1 Mapping maps

        :markdown
          Also map-based mapping methods are supported. The following shows an example:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              public interface SourceTargetMapper {

                  @MapMapping(valueDateFormat = "dd.MM.yyyy")
                  Map<String, String> longDateMapToStringStringMap(Map<Long, Date> source);
              }

        :markdown
          Similar to iterable mappings, the generated code will iterate through the source map, convert each value and key (either by means of an implicit conversion or by invoking another mapping method) and put them into the target map:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              //GENERATED CODE
              @Override
              public Map<Long, Date> stringStringMapToLongDateMap(Map<String, String> source) {
                  if ( source == null ) {
                      return null;
                  }

                  Map<Long, Date> map = new HashMap<Long, Date>();

                  for ( Map.Entry<String, String> entry : source.entrySet() ) {

                      Long key = Long.parseLong( entry.getKey() );
                      Date value;
                      try {
                          value = new SimpleDateFormat( "dd.MM.yyyy" ).parse( entry.getValue() );
                      }
                      catch( ParseException e ) {
                          throw new RuntimeException( e );
                      }

                      map.put( key, value );
                  }

                  return map;
              }
              
        :markdown
          MapStruct has a `CollectionMappingStrategy`, with the possible values: `ACCESSOR_ONLY`, `SETTER_PREFERRED` and `ADDER_PREFERRED`.
          
          In the table below, the dash `-` indicates a property name. Next, the trailing `s` indicates the plural form. The table explains the options and how they are apply to the presence/absense of a `set-s`, `add-` and / or `get-s` method on the target object: 

          
        %table.table
          %thead
            %tr
              %th Option
              %th Only target set-s Available
              %th Only target add- Available
              %th Both set-s / add- Available
              %th No set-s / add- Available
              %th 
                :markdown
                  Existing Target
                  (`@TargetType`)
          %tbody
            %tr
              %td
                :markdown
                  `ACCESSOR_ONLY`
              %td set-s
              %td get-s
              %td set-s
              %td get-s
              %td get-s
            %tr
              %td 
                :markdown
                  `SETTER_PREFERRED`
              %td set-s
              %td add-
              %td set-s
              %td get-s
              %td get-s
            %tr
              %td 
                :markdown
                  `ADDER_PREFERRED`
              %td set-s
              %td add-
              %td add-
              %td get-s
              %td get-s                  

        :markdown
          Some background\: An `adder` method is typically used in case of [generated (JPA) entities](http://www.eclipse.org/webtools/dali/), to add a single element (entity) to an underlying collection. Invoking the adder establishes a parent-child relation between parent - the bean (entity) on which the adder is invoked - and its child(ren), the elements (entities) in the collection. To find the appropriate `adder`, MapStruct will try to make a match between the generic parameter type of the underlying collection and the single argument of a candidate `adder`. When there are more candidates, the plural `setter` / `getter` name is converted to singular and will be used in addition to make a match.
          
          The option `DEFAULT` should not be used explicitely. It is used to distinguish between an explicit user desire to override the default in a `@MapperConfig` from the implicit Mapstruct choice in a `@Mapper`. The option `DEFAULT` is synonymous to `ACCESSOR_ONLY`.
          
        .alert.alert-info
          :markdown
            **Tip!** When working with an `adder` method and JPA entities, Mapstruct assumes that the target collections are initialized with a collection implementation (e.g. an `ArrayList`). You can use factories to create a new target entity with intialized collections in stead of Mapstruct creating the target entity by its constructor.

        %h4#section-06-02 6.2 Implementation types used for collection mappings

        :markdown
          When an iterable or map mapping method declares an interface type as return type, one of its implementation types will be instantiated in the generated code. The following table shows the supported interface types and their corresponding implementation types as instantiated in the generated code:

        %table.table
          %thead
            %tr
              %th Interface type
              %th Implementation type
          %tbody
            %tr
              %td
                :markdown
                  `Iterable`
              %td
                :markdown
                  `ArrayList`
            %tr
              %td
                :markdown
                  `Collection`
              %td
                :markdown
                  `ArrayList`
            %tr
              %td
                :markdown
                  `List`
              %td
                :markdown
                  `ArrayList`
            %tr
              %td
                :markdown
                  `Set`
              %td
                :markdown
                  `HashSet`
            %tr
              %td
                :markdown
                  `SortedSet`
              %td
                :markdown
                  `TreeSet`
            %tr
              %td
                :markdown
                  `NavigableSet`
              %td
                :markdown
                  `TreeSet`
            %tr
              %td
                :markdown
                  `Map`
              %td
                :markdown
                  `HashMap`
            %tr
              %td
                :markdown
                  `SortedMap`
              %td
                :markdown
                  `TreeMap`
            %tr
              %td
                :markdown
                  `NavigableMap`
              %td
                :markdown
                  `TreeMap`
            %tr
              %td
                :markdown
                  `ConcurrentMap`
              %td
                :markdown
                  `ConcurrentHashMap`
            %tr
              %td
                :markdown
                  `ConcurrentNavigableMap`
              %td
                :markdown
                  `ConcurrentSkipListMap`

    .row
      .span9
        %h3#section-07 7. Mapping enum types

        :markdown
          MapStruct supports the generation of methods which map one Java enum type into another.

          By default, each constant from the source enum is mapped to a constant with the same name in the target enum type. If required, a constant from the source enum may be mapped to a constant with another name with help of the `@Mapping` annotation. Several constants from the source enum can be mapped to the same constant in the target type.

          The following shows an example:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public interface OrderMapper {

                  OrderMapper INSTANCE = Mappers.getMapper( OrderMapper.class );

                  @Mappings({
                      @Mapping(source = "EXTRA", target = "SPECIAL"),
                      @Mapping(source = "STANDARD", target = "DEFAULT"),
                      @Mapping(source = "NORMAL", target = "DEFAULT")
                  })
                  ExternalOrderType orderTypeToExternalOrderType(OrderType orderType);
              }

        :markdown
          Note that an error will be raised by MapStruct in case a constant of the source enum type does not have a corresponding constant with the same name in the target type and also is not mapped to another constant via `@Mapping`. This ensures that all constants are mapped in a safe and predictable manner.

    .row
      .span9
        %h3#section-08 8. Object factories

        :markdown
          By default, the generated code for mapping one bean type into another will call the default constructor to instantiate the target type.

          Alternatively you can plug in custom object factories which will be invoked to obtain instances of the target type. One use case for this is JAXB which creates `ObjectFactory` classes for obtaining new instances of schema types.

          To do make use of custom factories register them via `@Mapper#uses()` as described in [section 5.3](#section-05-3). When creating the target object of a bean mapping, MapStruct will look for a parameterless method, or a method with only one `@TargetType` parameter that returns the required target type and invoke this method instead of calling the default constructor:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              public class DtoFactory {

                   public CarDto createCarDto() {
                       return // ... custom factory logic
                   }
              }

              public class EntityFactory {

                   public <T extends BaseEntity> T createEntity(@TargetType Class<T> entityClass) {
                       return // ... custom factory logic
                   }
              }

              @Mapper(uses= { DtoFactory.class, EntityFactory.class } )
              public interface CarMapper {

                  OrderMapper INSTANCE = Mappers.getMapper( CarMapper.class );

                  CarDto carToCarDto(Car car);

                  Car carDtoToCar(CarDto carDto);
              }

              //GENERATED CODE
              public class CarMapperImpl implements CarMapper {

                  private final DtoFactory dtoFactory = new DtoFactory();

                  private final EntityFactory entityFactory = new EntityFactory();

                  @Override
                  public CarDto carToCarDto(Car car) {
                      if ( car == null ) {
                          return null;
                      }

                      CarDto carDto = dtoFactory.createCarDto();

                      //map properties...

                      return carDto;
                  }

                  @Override
                  public Car carDtoToCar(CarDto carDto) {
                      if ( carDto == null ) {
                          return null;
                      }

                      Car car = entityFactory.createEntity( Car.class );

                      //map properties...

                      return car;
                  }
              }

    .row
      .span9
        %h3#section-09 9. Customizing mappings using decorators

        :markdown
          In certain cases it may be required to customize a generated mapping method, e.g. to set an additional property in the target object which can't be set by a generated method implementation. MapStruct supports this requirement using decorators.

        .alert.alert-warn
          :markdown
            **Note!** Decorators are an experimental feature as of the 1.0.0.Beta1 release. They are only supported for the default component model, not when working with the CDI or Spring models.

        :markdown
          To apply a decorator to a mapper class specify it using the `@DecoratedWith` annotation:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              @DecoratedWith(PersonMapperDecorator.class)
              public interface PersonMapper {

                  PersonMapper INSTANCE = Mappers.getMapper( PersonMapper.class );

                  PersonDto personToPersonDto(Person person);

                  AddressDto addressToAddressDto(Address address);
              }

        :markdown
          The decorator must be a sub-type of the decorated mapper type. You can make it an abstract class which allows to only implement those methods of the mapper interface which you want to customize. All non-implemented methods will be generated using the default generation routine.

          The `PersonMapperDecorator` shown below customizes the `personToPersonDto()`. It sets an additional attribute which is not present in the source type of the mapping. The `addressToAddressDto()` method is not customized.

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              public abstract class PersonMapperDecorator implements PersonMapper {

                  private final PersonMapper delegate;

                  public PersonMapperDecorator(PersonMapper delegate) {
                      this.delegate = delegate;
                  }

                  @Override
                  public PersonDto personToPersonDto(Person person) {
                      PersonDto dto = delegate.personToPersonDto( person );
                      dto.setFullName( person.getFirstName() + " " + person.getLastName() );
                      return dto;
                  }
              }

        :markdown
          As shown in the example, you can optionally inject a delegate with the generated default implementations and use this delegate in your customized decorator methods. To do so, define a constructor with a single parameter which accepts the type of the decorated mapper.

    .row
      .span9
        %h3#section-10 10. Reverse mappings

        :markdown
          In some cases bi-directional mappings are required, e.g. from entity to DTO and from DTO to entity. For this purpose, simply declare a method with the required parameter and return type on the mapping interface which also declares the forward mapping method.
          
          Use the `@InheritInverseConfiguration` to indicate that this method is marked as reverse mapping.

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public interface CarMapper {

                  @Mapping(source = "numberOfSeats", target = "seatCount")
                  CarDto carToDto(Car car);

                  @InheritInverseConfiguration
                  Car carDtoToCar(CarDto carDto);
              }

        :markdown
          Here the `carDtoToCar()` method is the reverse mapping method for `carToDto()`. Note that any attribute mappings from `carToDto()` will be applied to the corresponding reverse mapping method as well. They are automatically reversed and copied to the method with the `@InheritInverseConfiguration` annotation. 

          Specific mappings from the inversed method can (optionally) be overridden by  `ignore`, `expression` or `constant` in the mapping, e.g. like this: `@Mapping(target = "numberOfSeats", ignore=true)`. 

          If multiple forward methods qualify as per their source and target types, the method from which to inherit the configuration from can be specified using the `name` property like this: `@InheritInverseConfiguration(name = "carToDto")`.

          Nested properties are excluded (silently ignored) from reverse mapping. The same holds true for expressions and constants. Reverse mapping will take place automatically when the source property name and target property name are identical. Otherwise, `@Mapping` should specify both the target name and source name. In all cases, a suitable mapping method needs to be in place for the reverse mapping.

    .row
      .span9
        %h3#section-11 11. Exceptions

        :markdown
          Calling applications may require handling of exceptions when calling a mapping method. These exceptions could be thrown by hand-written logic and by the generated built-in mapping methods or type-conversions of MapStruct. When the calling application requires handling of exceptions, a throws clause can be defined in the mapping method:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper(uses = HandWritten.class)
              public interface CarMapper {

                  CarDto carToCarDto(Car car) throws GearException;
              }

        :markdown
          The hand written logic might look like this:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              public class HandWritten {

                  private static final String[] GEAR = {"ONE", "TWO", "THREE", "OVERDRIVE", "REVERSE"};

                  public String toGear(Integer gear) throws GearException, FatalException {
                      if ( gear == null ) {
                          throw new FatalException("null is not a valid gear");
                      }

                      if ( gear < 0 && gear > GEAR.length ) {
                          throw new GearException("invalid gear");
                      }
                      return GEAR[gear];
                  }
              }

        :markdown
          MapStruct now, wraps the `FatalException` in a `try-catch` block and rethrows an unchecked `RuntimeException`. MapStruct delegates handling of the `GearException` to the application logic because it is defined as throws clause in the `carToCarDto` method:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Override
              public CarDto carToCarDto(Car car) throws GearException {
                  if ( car == null ) {
                      return null;
                  }

                  CarDto carDto = new CarDto();
                  try {
                      carDto.setGear( handWritten.toGear( car.getGear() ) );
                  }
                  catch ( FatalException e ) {
                      throw new RuntimeException( e );
                  }

                  return carDto;
              }


        :markdown
          Some **notes** on null checks. MapStruct does provide null checking only when required: when applying type-conversions or constructing a new type by invoking its constructor. This means that the user is responsible in hand-written code for returning valid non-null objects. Also null objects can be handed to hand-written code, since MapStruct does not want to make assumptions on the meaning assigned by the user to a null object. Hand-written code has to deal with this.

    .row
      .span9
        %h3#section-12 12. Constants

        :markdown
          MapStruct supports the usage of constants. Constants are subject to type conversion either via built-in conversions or the invocation of other mapping methods. A mapping with a constant must not include a reference to a source property. The following examples shows some mappings using constants:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
               @Mapper(uses = StringListMapper.class)
               public interface SourceTargetMapper {

                   SourceTargetMapper INSTANCE = Mappers.getMapper(
                       SourceTargetMapper.class
                   );

                   @Mappings( {
                       @Mapping( target = "stringConstant", constant = "Constant Value"),
                       @Mapping( target = "integerConstant", constant = "14"),
                       @Mapping( target = "longWrapperConstant", constant = "3001"),
                       @Mapping(
                           target = "dateConstant",
                           dateFormat = "dd-MM-yyyy",
                           constant = "09-01-2014"
                       ),
                       @Mapping( target = "stringListConstants", constant = "jack-jill-tom" )
                   } )
                   Target sourceToTarget(Source s);
                   }
               }

        :markdown
          The String `"Constant Value"` is set as is to the target property `stringConstant`. The value `"3001"` is type-converted to the `Long` (wrapper) class of target property `longWrapperConstant`. Date properties also require a date format. The constant `"jack-jill-tom"` demonstrates how the hand-written class `StringListMapper` is invoked to map the dash-separated list into a `List<String>`.

    .row
      .span9
        %h3#section-13 13. Expressions

        :markdown
          By means of Expressions it will be possible to include constructs from a number of languages.

          Currently only Java is supported as language. This feature is e.g. useful to invoke constructors. The entire source object is available for usage in the expression. Care should be taken to insert only valid Java code: MapStruct will not validate the expression at generation-time, but errors will show up in the generated classes during compilation.

          The example below demonstrates how two source properties can be mapped to one target:


        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper
              public interface SourceTargetMapper {

                  SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );

                  @Mapping(target = "timeAndFormat",
                       expression = "java( new org.sample.TimeAndFormat( s.getTime(), s.getFormat() ) )")
                  Target sourceToTarget(Source s);
              }

        :markdown
          The example demonstrates how the source properties `time` and `format` are composed into one target property `TimeAndFormat`. Please note that the fully qualified package name is specified because MapStruct does not take care of the import of the `TimeAndFormat` class (unless its used otherwise explicitly in the `SourceTargetMapper`). This can be resolved by defining `imports` on the `@Mapper` annotation.
          
        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              imports org.sample.TimeAndFormat;
              
              @Mapper( imports = TimeAndFormat.class )
              public interface SourceTargetMapper {

                  SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );

                  @Mapping(target = "timeAndFormat",
                       expression = "java( new TimeAndFormat( s.getTime(), s.getFormat() ) )")
                  Target sourceToTarget(Source s);
              }                        

    .row
      .span9
        %h3#section-14 14. Shared configurations

        :markdown
          MapStruct offers the possibility to define a shared configuration by pointing to a central class annotated with `@MapperConfig`. For a mapper to use the shared configuration, the configuration class needs to be defined in the `@Mapper#config` property.

          The `@MapperConfig` annotation has the same attributes as the `@Mapper` annotation. Any attributes not given via `@Mapper` will be inherited from the shared configuration. Attributes specified in `@Mapper` take precedence over the attributes specified via the referenced configuration class. List properties such as `uses` are simply combined:

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @MapperConfig(
                  uses = CustomMapperViaMapperConfig.class,
                  unmappedTargetPolicy = ReportingPolicy.ERROR
              )
              public class CentralConfig {
              }

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper(config = CentralConfig.class, uses = { CustomMapperViaMapper.class } )
              // Effective configuration:
              // @Mapper(
              //     uses = { CustomMapperViaMapper.class, CustomMapperViaMapperConfig.class },
              //     unmappedTargetPolicy = ReportingPolicy.ERROR
              // )
              public interface SourceTargetMapper {
                ...
              }

    .row
      .span9
        %h3#section-15 15. Qualifiers

        :markdown
            In many occasions one requires mapping methods with the same method signature (appart from the name) that have different behavior. MapStruct has a handy mechanism to deal with such situations: `@Qualifier`. A ‘qualifier’ is a custom annotation that the user can write, ‘stick onto’ a mapping method which is included as used mapper, and can be referred to in a bean property mapping, iterable mapping or map mapping.  Multiple qualifiers can be ‘stuck onto’ a method and mapping. 

            So, lets say there is a hand-written method to map titles with a `String` return type and `String` argument amongst many other referenced mappers with the same `String` return type  - `String` argument signature:
            

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              public class Titles {

                  public String translateTitleEG(String title) {
                      // some mapping logic
                  }
                  
                  public String translateTitleGE(String title) {
                      // some mapping logic
                  }
              }  

        :markdown
            And a mapper using this handwritten mapper, in which source and target have a property 'title' that should be mapped:
            

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper( uses = Titles.class )
              public interface MovieMapper {

                   GermanRelease toGerman( OriginalRelease movies );

              }
              


        :markdown
             Without the use of qualifiers, this would result in an ambiguous mapping method error, because 2 qualifying methods are found (`translateTitleEG`, `translateTitleGE`) and MapStruct would not have a hint which one to choose.
        
             Enter the qualifier approach:
             
                          
        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Qualifier
              @Target(ElementType.TYPE)
              @Retention(RetentionPolicy.SOURCE)
              public @interface TitleTranslator {
              }
              
        :markdown
             And, some qualifiers to indicate which translator to use to map from source language to target language:
             
             
        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Qualifier
              @Target(ElementType.METHOD)
              @Retention(RetentionPolicy.SOURCE)
              public @interface EnglishToGerman {
              }
            

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Qualifier
              @Target(ElementType.METHOD)
              @Retention(RetentionPolicy.SOURCE)
              public @interface GermanToEnglish {
              }             

        :markdown
             Please take note of the retention `TitleTranslator` on class level, `EnglishToGerman`, `GermanToEnglish` on method level! 
             
             Then, using the qualifiers, the mapping could look like this:
  
        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @Mapper( uses = Titles.class )
              public interface MovieMapper {

                   @Mapping( target = "title", qualifiedBy = { TitleTranslator.class, EnglishToGerman.class } )
                   GermanRelease toGerman( OriginalRelease movies );

              }           

        %pre.prettyprint.lang-java.linenums
          = preserve do
            :escaped
              @TitleTranslator
              public class Titles {

                  @EnglishToGerman
                  public String translateTitleEG(String title) {
                      // some mapping logic
                  }
                  
                  @GermanToEnglish                  
                  public String translateTitleGE(String title) {
                      // some mapping logic
                  }
              } 

        .alert.alert-warn
          :markdown
            **Note!** A class / method annotated with a qualifier will not qualify anymore for mappings that do not have the `qualifiedBy` element.


    .row
      .span9
        %h3#section-16 16. Controlling mapping result

        :markdown
          MapStruct offers control over the object to create when the source (argument) equals `null`. By default `null` will be returned. However, by means of the `NullValueMapping` annotation on mapping method level or the `nullValueMappingStrategy` element on `@Mapping` or `@MappingConfig` level this default outcome can be altered. There is one additional possibility: `RETURN_DEFAULT`. This means the following for:

        %ul
          %li

            :markdown
              `bean mappings`: an 'empty' target bean will be returned, with the exception of constants and expressions, they will be populated when present.
          %li

            :markdown
              `list`: an empty iterable will be returned.

          %li

            :markdown
              `map`: an empty map will be returned.

        :markdown
          The strategy works in a hierarchical fashion, similar to the `CollectionMappingStrategy` explained earlier. An `@NullValueMapping` annotation on mapping method level will override the `@Mapping#nullValueMappingStrategy`. Just as the `@Mapping#nullValueMappingStrategy` will override the `@MappingConfig#nullValueMappingStrategy`.

  .span3
    #toc{ :"data-offset-top"=>"0", :"data-spy"=>"affix" }
      %h5 Contents
      %ol.nav.nav-list
        %li.active
          %a{ :href=>"#section-01" } Introduction
        %li
          %a{ :href=>"#section-02" } Set up
        %li
          %a{ :href=>"#section-03" } Defining a mapper
        %li
          %a{ :href=>"#section-04" } Retrieving a mapper
        %li
          %a{ :href=>"#section-05" } Data type conversions
        %li
          %a{ :href=>"#section-06" } Mapping collections
        %li
          %a{ :href=>"#section-07" } Mapping enum types
        %li
          %a{ :href=>"#section-08" } Object factories
        %li
          %a{ :href=>"#section-09" } Decorators
        %li
          %a{ :href=>"#section-10" } Reverse mappings
        %li
          %a{ :href=>"#section-11" } Exceptions
        %li
          %a{ :href=>"#section-12" } Constants
        %li
          %a{ :href=>"#section-13" } Expressions
        %li
          %a{ :href=>"#section-14" } Shared configurations
        %li
          %a{ :href=>"#section-15" } Qualifiers
        %li
          %a{ :href=>"#section-16" } Controlling mapping result
    :javascript
      (function(jQuery){
        jQuery( document ).ready( function() {
          $(document.body).scrollspy({
            target: "#toc"
          });
        });
      }(jQuery))
